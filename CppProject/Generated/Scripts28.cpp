/*
	NOTE:
	This file was autogenerated by CppGen, changes may be overwritten and forever lost!
	Modify at your own risk!
	
	[ Generated on 2023.06.16 19:54:52 ]
*/

#include "Scripts.hpp"

namespace CppProject
{
	void draw_separator_vertical(VarType xx, VarType yy, RealType hei)
	{
		RealType alpha = draw_get_alpha();
		draw_set_alpha(alpha * global::a_border);
		render_set_culling(false);
		draw_line_width_color((IntType)(xx), (IntType)(yy), (IntType)(xx), (IntType)(yy + hei), IntType(1), (IntType)(global::c_border), (IntType)(global::c_border));
		render_set_culling(true);
		draw_set_alpha(alpha);
	}
	
	void draw_subheader(ScopeAny self, VarType cat, VarType xx, VarType yy, RealType w, RealType h)
	{
		BoolType mouseon;
		VarType cap, iconframe;
		draw_set_font(sInt(font_subheading));
		cap = string_limit(text_get({ ObjType(obj_category, cat)->name }), sVar(dw) - (h + IntType(4)));
		mouseon = app_mouse_box(self, xx, yy, w, h) && sBool(content_mouseon);
		microani_set(ObjType(obj_category, cat)->name + /*"close"*/ STR(1117), null_, false, false, ObjType(obj_category, cat)->show, false);
		IntType color;
		RealType alpha, frame;
		VarType focus;
		focus = max({ global::microani_arr.Value(e_microani_ACTIVE), global::microani_arr.Value(e_microani_PRESS) });
		color = merge_color((IntType)(global::c_text_tertiary), (IntType)(global::c_text_secondary), global::microani_arr.Value(e_microani_HOVER));
		color = merge_color(color, (IntType)(global::c_accent), focus);
		color = merge_color(color, global::c_accent_hover, global::microani_arr.Value(e_microani_HOVER) * global::microani_arr.Value(e_microani_ACTIVE));
		color = merge_color(color, global::c_accent_pressed, global::microani_arr.Value(e_microani_PRESS) * global::microani_arr.Value(e_microani_ACTIVE));
		alpha = lerp(global::a_text_tertiary, global::a_text_secondary, global::microani_arr.Value(e_microani_HOVER));
		alpha = lerp(alpha, global::a_accent, focus);
		frame = floor((sprite_get_number(ID_spr_chevron_ani) - IntType(1)) * global::microani_arr.Value(e_microani_ACTIVE));
		if (is_array(ObjType(obj_category, cat)->icon))
			iconframe = (ObjType(obj_theme, sInt(setting_theme))->dark ? ObjType(obj_category, cat)->icon.Value(IntType(1)) : ObjType(obj_category, cat)->icon.Value(IntType(0)));
		else
			iconframe = ObjType(obj_category, cat)->icon;
		
		draw_image({ ID_spr_chevron_ani, frame, xx + w - IntType(11), yy + h / 2.0, IntType(1), IntType(1), color, alpha });
		if (global::_app->panel_compact > 0)
			draw_label(self, { cap, xx + IntType(4), yy + (h / 2.0) - IntType(1), fa_left, fa_middle, color, alpha });
		else
		{
			draw_image({ ID_spr_icons, iconframe, xx + IntType(12), yy + h / 2.0, IntType(1), IntType(1), color, alpha });
			draw_label(self, { cap, xx + IntType(26), yy + (h / 2.0) - IntType(1), fa_left, fa_middle, color, alpha });
		}
		
		microani_update({ mouseon, (mouseon && sBool(mouse_left)), ObjType(obj_category, cat)->show });
		if (mouseon)
		{
			sInt(mouse_cursor) = cr_handpoint;
			if (sBool(mouse_left_released))
				ObjType(obj_category, cat)->show = !(ObjType(obj_category, cat)->show > 0);
		}
	}
	
	RealType draw_surface_box_center(VarType surf, RealType xx, RealType yy, VarType w, VarType h)
	{
		RealType sw, sh, scale;
		if (!surface_exists((IntType)(surf)))
			return IntType(0);
		sw = surface_get_width((IntType)(surf));
		sh = surface_get_height((IntType)(surf));
		if (sw / sh < (RealType)w / h)
		{
			scale = (RealType)h / sh;
			xx += (w - scale * sw) / 2.0;
			w = sw * scale;
		}
		else
		{
			scale = (RealType)w / sw;
			yy += (h - scale * sh) / 2.0;
			h = sh * scale;
		}
		
		xx = floor(xx);
		yy = floor(yy);
		w = ceil(w);
		h = ceil(h);
		draw_surface_ext((IntType)(surf), (IntType)(xx), (IntType)(yy), scale, scale, 0.0, c_white, 1.0);
		return 0.0;
	}
	
	void draw_surface_exists(VarType surf, VarType xx, VarType yy)
	{
		if (surface_exists((IntType)(surf)))
			draw_surface_ext((IntType)(surf), (IntType)(xx), (IntType)(yy), 1.0, 1.0, 0.0, c_white, draw_get_alpha());
	}
	
	void draw_surface_size(VarType surf, VarType xx, VarType yy, VarType w, VarType h)
	{
		if (surface_exists((IntType)(surf)))
			draw_surface_ext((IntType)(surf), (IntType)(xx), (IntType)(yy), (RealType)w / surface_get_width((IntType)(surf)), (RealType)h / surface_get_height((IntType)(surf)), 0.0, -IntType(1), draw_get_alpha());
		else
			draw_box(xx, yy, w, h, false, c_black, draw_get_alpha());
		
	}
	
	RealType draw_switch(ScopeAny self, StringType name, VarType xx, VarType yy, VarType active, IntType script, StringType tip, BoolType disabled)
	{
		VarType text, switchx, switchy, w;
		RealType h, thumbgoal;
		BoolType pressed;
		text = text_get({ name });
		w = sVar(dw);
		h = sReal(ui_small_height);
		switchx = (xx + sVar(dw) - IntType(22));
		switchy = (yy + (h / 2.0) - IntType(7));
		if (xx + w < sVar(content_x) || xx > sVar(content_x) + sVar(content_width) || yy + h < sVar(content_y) || yy > sVar(content_y) + sVar(content_height))
			return IntType(0);
		BoolType mouseon, mouseclick;
		mouseon = app_mouse_box(self, switchx, switchy, h, IntType(16)) && sBool(content_mouseon) && !disabled;
		mouseclick = mouseon && sBool(mouse_left);
		pressed = false;
		if (mouseon)
		{
			if (sBool(mouse_left) || sBool(mouse_left_released))
				pressed = true;
			sInt(mouse_cursor) = cr_handpoint;
		}
		if (pressed)
			thumbgoal = 0.5;
		else
			if (active > 0)
				thumbgoal = IntType(1);
			else
				thumbgoal = IntType(0);
		
		
		microani_set(name, script, mouseon, mouseclick, active, disabled, IntType(1), IntType(0), thumbgoal);
		IntType offcolor, oncolor, color;
		RealType offalpha, onalpha, alpha;
		offcolor = merge_color((IntType)(global::c_text_secondary), (IntType)(global::c_text_main), global::microani_arr.Value(e_microani_HOVER));
		offcolor = merge_color(offcolor, (IntType)(global::c_accent), global::microani_arr.Value(e_microani_PRESS));
		offalpha = lerp(global::a_text_secondary, global::a_text_main, global::microani_arr.Value(e_microani_HOVER));
		offalpha = lerp(offalpha, global::a_accent, global::microani_arr.Value(e_microani_PRESS));
		oncolor = merge_color((IntType)(global::c_accent), global::c_accent_hover, global::microani_arr.Value(e_microani_HOVER));
		oncolor = merge_color(oncolor, global::c_accent_pressed, global::microani_arr.Value(e_microani_PRESS));
		onalpha = lerp(global::a_accent, global::a_accent_hover, global::microani_arr.Value(e_microani_HOVER));
		onalpha = lerp(onalpha, global::a_accent_pressed, global::microani_arr.Value(e_microani_PRESS));
		color = merge_color(offcolor, oncolor, global::microani_arr.Value(e_microani_ACTIVE));
		alpha = lerp(offalpha, onalpha, global::microani_arr.Value(e_microani_ACTIVE));
		color = merge_color(color, (IntType)(global::c_text_tertiary), global::microani_arr.Value(e_microani_DISABLED));
		alpha = lerp(alpha, global::a_text_tertiary, global::microani_arr.Value(e_microani_DISABLED));
		draw_box(switchx, switchy, IntType(20), IntType(14), false, color, alpha);
		VarType buttonx, buttony;
		buttonx = switchx + IntType(2) + floor(IntType(8) * global::microani_arr.Value(e_microani_GOAL_EASE));
		buttony = switchy + IntType(2);
		draw_box(buttonx, buttony, IntType(8), IntType(10), false, global::c_button_text, IntType(1));
		draw_box_bevel({ buttonx, buttony, IntType(8), IntType(10), IntType(1), ObjType(obj_theme, sInt(setting_theme))->name == /*"light"*/ STR(653) });
		draw_box_hover({ switchx, switchy, IntType(20), IntType(14), global::microani_arr.Value(e_microani_PRESS) });
		draw_set_font(sInt(font_label));
		draw_label(self, { string_limit(text, w - IntType(32)), xx, yy + (h / 2.0), fa_left, fa_middle, lerp(global::c_text_secondary, global::c_text_tertiary, global::microani_arr.Value(e_microani_DISABLED)), lerp(global::a_text_secondary, global::a_text_tertiary, global::microani_arr.Value(e_microani_DISABLED)) });
		microani_update({ mouseon, mouseclick, active, disabled, IntType(0), thumbgoal });
		draw_help_circle(self, tip, xx + string_width(text) + IntType(4), yy + (h / 2.0) - IntType(10), disabled);
		if (pressed && sBool(mouse_left_released))
		{
			if (script != null_)
				script_execute(self, { script, !(active > 0) });
			return true;
		}
		return 0.0;
	}
	
	RealType draw_textfield(ScopeAny self, StringType name, VarType xx, VarType yy, VarType w, RealType h, IntType textbox, IntType script, VarType placeholder, StringType labelpos, BoolType err)
	{
		IntType capwidth;
		VarType fieldy;
		capwidth = IntType(0);
		fieldy = yy;
		draw_set_font(sInt(font_label));
		if (labelpos == /*"top"*/ STR(188))
			fieldy += (label_height + IntType(8));
		else
			if (labelpos == /*"none"*/ STR(914))
				capwidth = IntType(0);
			else
				capwidth = string_width(text_get({ name })) + IntType(8);
		
		
		if (xx + w < sVar(content_x) || xx > sVar(content_x) + sVar(content_width) || yy + h < sVar(content_y) || yy > sVar(content_y) + sVar(content_height))
		{
			if (sBool(textbox_jump))
				ds_list_add({ sInt(textbox_list), ArrType::From({ textbox, sVar(content_tab), yy, sVar(content_y), sVar(content_height) }) });
			return IntType(0);
		}
		RealType update = draw_inputbox(self, { name, xx + capwidth, fieldy, w - capwidth, h, placeholder, textbox, script, false, err });
		draw_set_font(sInt(font_label));
		VarType labelcolor;
		RealType labelalpha;
		labelcolor = merge_color((IntType)(global::c_text_secondary), (IntType)(global::c_text_main), global::microani_arr.Value(e_microani_HOVER));
		labelcolor = merge_color((IntType)(labelcolor), (IntType)(global::c_accent), global::microani_arr.Value(e_microani_ACTIVE));
		labelalpha = lerp(global::a_text_secondary, global::a_text_main, global::microani_arr.Value(e_microani_HOVER));
		labelalpha = lerp(labelalpha, global::a_accent, global::microani_arr.Value(e_microani_ACTIVE));
		if (err)
		{
			labelcolor = global::c_error;
			labelalpha = IntType(1);
		}
		if (labelpos == /*"top"*/ STR(188))
			draw_label(self, { string_limit(text_get({ name }), sVar(dw)), xx, yy - IntType(3), fa_left, fa_top, labelcolor, labelalpha });
		else
			if (labelpos != /*"none"*/ STR(914))
				draw_label(self, { text_get({ name }), xx, yy + h / 2.0, fa_left, fa_middle, labelcolor, labelalpha });
		
		return update;
	}
	
	VarType draw_textfield_group(ScopeAny self, StringType name, VarType xx, VarType yy, VarType wid, VarType mul, VarType minval, VarType maxval, RealType snapval, RealType showcaption, RealType stack, RealType colortype, BoolType drag, BoolType textfield_update)
	{
		RealType vertical, hei;
		VarType fieldx, fieldy, fieldwid, fieldupdate;
		vertical = (global::_app->panel_compact > 0) && stack > 0;
		fieldx = xx;
		fieldy = yy;
		fieldwid = (vertical > 0) ? wid : VarType(((RealType)wid / sReal(textfield_amount)));
		fieldupdate = VarType();
		hei = ((vertical > 0) ? (sReal(ui_small_height) * sReal(textfield_amount)) : sReal(ui_small_height)) + ((label_height + IntType(8)) * showcaption);
		if (xx + wid < sVar(content_x) || xx > sVar(content_x) + sVar(content_width) || yy + hei < sVar(content_y) || yy > sVar(content_y) + sVar(content_height))
		{
			textfield_group_reset(self);
			return IntType(0);
		}
		IntType dragw;
		BoolType mouseon;
		mouseon = app_mouse_box(self, xx, yy, wid, hei) && sBool(content_mouseon);
		microani_set(string(sVar(textfield_textbox).Value(sReal(textfield_amount) - IntType(1))) + sVar(textfield_name).Value(sReal(textfield_amount) - IntType(1)), sVar(textfield_script).Value(sReal(textfield_amount) - IntType(1)), false, false, false, false, IntType(1), false);
		VarType active = ObjType(micro_animation, global::current_microani)->custom;
		microani_set(name, null_, mouseon || active > 0, false, false);
		microani_update({ mouseon || active > 0, false, false });
		if (showcaption > 0)
		{
			draw_set_font(sInt(font_label));
			draw_label(self, { string_limit(text_get({ name }), sVar(dw)), xx, yy, fa_left, fa_top, global::c_text_secondary, global::a_text_secondary });
			yy += (label_height + IntType(8));
		}
		hei = sReal(ui_small_height);
		fieldx = xx;
		fieldy = yy;
		dragw = IntType(16);
		draw_box(xx, yy, wid, ((vertical > 0) ? sReal(textfield_amount) * hei : hei), false, global::c_level_top, draw_get_alpha());
		if (vertical > 0)
			draw_outline(fieldx, fieldy, wid, sReal(textfield_amount) * hei, IntType(1), global::c_border, global::a_border, true);
		else
			draw_outline(fieldx, fieldy, wid, hei, IntType(1), global::c_border, global::a_border, true);
		
		draw_set_font(sInt(font_label));
		for (IntType i = IntType(0); i < sReal(textfield_amount); i++)
		{
			if (i > IntType(0))
			{
				if (vertical > 0)
					draw_box(fieldx + IntType(1), fieldy - IntType(1), fieldwid - IntType(2), IntType(1), false, global::c_border, global::a_border);
				else
					draw_box(fieldx, fieldy + IntType(1), IntType(1), hei - IntType(2), false, global::c_border, global::a_border);
				
			}
			if (vertical > 0)
				fieldy += hei;
			else
				fieldx += fieldwid;
			
			dragw = max({ dragw, string_width(text_get({ sVar(textfield_caption).Value(i) != null_ ? sVar(textfield_caption).Value(i) : sVar(textfield_name).Value(i) })) + IntType(16) });
		}
		fieldx = xx;
		fieldy = yy;
		VarType boxwid, boxy, update;
		RealType boxhei;
		active = false;
		for (IntType i = IntType(0); i < sReal(textfield_amount); i++)
		{
			global::axis_edit = sVar(textfield_axis).Value(i);
			boxhei = hei;
			boxwid = fieldwid;
			boxy = fieldy;
			if (i < (sReal(textfield_amount) - IntType(1)) && !(vertical > 0))
				boxwid += IntType(1);
			if (i != IntType(0) && vertical > 0)
			{
				boxhei += IntType(1);
				boxy -= 1.0;
			}
			mouseon = app_mouse_box(self, fieldx, boxy, boxwid, boxhei) && sBool(content_mouseon);
			if (sVar(textfield_min) != null_)
			{
				minval = sVar(textfield_min).Value(i);
				maxval = sVar(textfield_max).Value(i);
			}
			context_menu_area(self, { fieldx, boxy, boxwid, boxhei, /*"contextmenuvalue"*/ STR(1087), sVar(textfield_value).Value(i), e_context_type_NUMBER, sVar(textfield_script).Value(i), sVar(textfield_default).Value(i) });
			microani_set(string(sVar(textfield_textbox).Value(i)) + sVar(textfield_name).Value(i), sVar(textfield_script).Value(i), mouseon || sVar(window_focus) == string(sVar(textfield_textbox).Value(i)), false, (mouseon && sBool(mouse_left)) || (sVar(window_focus) == string(sVar(textfield_textbox).Value(i))));
			VarType focus;
			IntType linecolor;
			RealType linealpha;
			focus = max({ global::microani_arr.Value(e_microani_PRESS), global::microani_arr.Value(e_microani_ACTIVE) });
			linecolor = merge_color((IntType)(global::c_border), (IntType)(global::c_text_tertiary), global::microani_arr.Value(e_microani_HOVER));
			linecolor = merge_color(linecolor, (IntType)(global::c_accent), focus);
			linealpha = lerp(0.0, global::a_text_tertiary, global::microani_arr.Value(e_microani_HOVER));
			linealpha = lerp(linealpha, global::a_accent, focus);
			VarType labelcolor;
			RealType labelalpha;
			if (colortype > IntType(0))
			{
				if (colortype == IntType(1))
				{
					if (global::axis_edit == X_)
						labelcolor = global::c_axisred;
					else
						if (global::axis_edit == Y_)
							labelcolor = ((sReal(setting_z_is_up) > 0) ? global::c_axisgreen : global::c_axisblue);
						else
							labelcolor = ((sReal(setting_z_is_up) > 0) ? global::c_axisblue : global::c_axisgreen);
					
					
				}
				else
					if (colortype == IntType(2))
					{
						if (global::axis_edit == X_)
							labelcolor = global::c_axiscyan;
						else
							if (global::axis_edit == Y_)
								labelcolor = ((sReal(setting_z_is_up) > 0) ? global::c_axisyellow : global::c_axismagenta);
							else
								labelcolor = ((sReal(setting_z_is_up) > 0) ? global::c_axismagenta : global::c_axisyellow);
						
						
					}
					else
						if (colortype == IntType(3))
						{
							if (i == IntType(0))
								labelcolor = global::c_axisred;
							else
								if (i == IntType(1))
									labelcolor = global::c_axisgreen;
								else
									labelcolor = global::c_axisblue;
							
							
						}
				
				
				labelalpha = IntType(1);
			}
			else
			{
				labelcolor = merge_color((IntType)(global::c_text_secondary), (IntType)(global::c_text_main), global::microani_arr.Value(e_microani_HOVER));
				labelcolor = merge_color((IntType)(labelcolor), (IntType)(global::c_accent), focus);
				labelalpha = lerp(global::a_text_secondary, global::a_text_main, global::microani_arr.Value(e_microani_HOVER));
				labelalpha = lerp(labelalpha, global::a_accent, focus);
			}
			
			if (sVar(textfield_icon).Value(i) == null_)
				draw_label(self, { text_get({ sVar(textfield_caption).Value(i) != null_ ? sVar(textfield_caption).Value(i) : sVar(textfield_name).Value(i) }), fieldx + IntType(8), boxy + ceil(boxhei / 2.0), fa_left, fa_middle, labelcolor, labelalpha, sInt(font_label) });
			else
				draw_image({ ID_spr_icons, sVar(textfield_icon).Value(i), floor(fieldx + 14.0), boxy + ceil(boxhei / 2.0), IntType(1), IntType(1), global::c_text_secondary, global::a_text_secondary });
			
			draw_outline(fieldx, boxy, boxwid, boxhei, IntType(1), global::c_level_middle, max({ focus, global::microani_arr.Value(e_microani_HOVER) }), true);
			draw_outline(fieldx, boxy, boxwid, boxhei, IntType(1), linecolor, linealpha, true);
			draw_box_hover({ fieldx, boxy, boxwid, boxhei, global::microani_arr.Value(e_microani_PRESS) });
			if (sVar(textfield_value).Value(i) < minval || sVar(textfield_value).Value(i) > maxval)
				draw_box(fieldx, boxy, boxwid, boxhei, false, global::c_error, global::a_accent_overlay);
			else
				if ((abs(maxval) + abs(minval)) < IntType(100000))
				{
					RealType perc = percent(sVar(textfield_value).Value(i), minval, maxval);
					draw_box(fieldx, boxy, boxwid * perc, boxhei, false, global::c_accent_hover, global::a_accent_overlay);
				}
			
			active = (active > 0 || sVar(window_focus) == string(sVar(textfield_textbox).Value(i)));
			microani_update({ mouseon, mouseon && sBool(mouse_left), sVar(window_focus) == string(sVar(textfield_textbox).Value(i)) || (sVar(window_busy) == sVar(textfield_name).Value(i) + /*"drag"*/ STR(30)) || (sVar(window_busy) == sVar(textfield_name).Value(i) + /*"press"*/ STR(1095)), false, active });
			draw_set_font(sInt(font_digits));
			BoolType update = textbox_draw(self, sVar(textfield_textbox).Value(i), fieldx + dragw, boxy + ceil(boxhei / 2.0) - IntType(7), boxwid - (IntType(8) + dragw), IntType(18), true, true);
			if (app_mouse_box(self, fieldx + dragw, boxy, boxwid - (IntType(8) + dragw), boxhei) && sBool(content_mouseon) && sVar(window_focus) != string(sVar(textfield_textbox).Value(i)))
			{
				if (sBool(mouse_left_released))
				{
					sVar(window_focus) = string(sVar(textfield_textbox).Value(i));
					sVar(window_busy) = /*""*/ STR(0);
				}
			}
			if (app_mouse_box(self, fieldx, boxy, boxwid, boxhei) && sBool(content_mouseon) && sVar(window_focus) != string(sVar(textfield_textbox).Value(i)) && drag)
			{
				sInt(mouse_cursor) = cr_size_we;
				if (sBool(mouse_left_pressed))
					sVar(window_busy) = sVar(textfield_name).Value(i) + /*"press"*/ STR(1095);
			}
			if (sVar(window_busy) == sVar(textfield_name).Value(i) + /*"press"*/ STR(1095))
			{
				sInt(mouse_cursor) = cr_size_we;
				if (!sBool(mouse_left))
				{
					sVar(window_focus) = string(sVar(textfield_textbox).Value(i));
					sVar(window_busy) = /*""*/ STR(0);
					app_mouse_clear(self);
				}
				else
					if (sReal(mouse_dx) != IntType(0))
					{
						sVar(dragger_drag_value) = sVar(textfield_value).Value(i);
						sVar(window_busy) = sVar(textfield_name).Value(i) + /*"drag"*/ STR(30);
					}
				
			}
			if (sVar(window_busy) == sVar(textfield_name).Value(i) + /*"drag"*/ STR(30))
			{
				sInt(mouse_cursor) = cr_none;
				sVar(dragger_drag_value) += (gmlGlobal::mouse_x - sInt(mouse_click_x)) * (sVar(textfield_mul).Value(i) == null_ ? mul : sVar(textfield_mul).Value(i)) * sReal(dragger_multiplier);
				window_mouse_set(sInt(mouse_click_x), sInt(mouse_click_y));
				RealType d;
				if (global::_app->setting_unlimited_values > 0)
					d = snap(sVar(dragger_drag_value), snapval) - sVar(textfield_value).Value(i);
				else
					d = clamp(snap(sVar(dragger_drag_value), snapval), minval, maxval) - sVar(textfield_value).Value(i);
				
				if (d != IntType(0) && sVar(textfield_script).Value(i) != null_ && textfield_update)
					script_execute(self, { sVar(textfield_script).Value(i), d, true });
				else
				{
					idVar(sVar(textfield_textbox)[i], text) = string_decimals(sVar(textfield_value).Value(i) + d);
					fieldupdate = sVar(textfield_textbox).Value(i);
				}
				
				if (!sBool(mouse_left))
				{
					sVar(window_busy) = /*""*/ STR(0);
					app_mouse_clear(self);
					script_execute(self, { sVar(textfield_script).Value(i), d, true });
				}
			}
			if (update)
			{
				VarType val = eval(idVar(sVar(textfield_textbox).Value(i), text), sVar(textfield_default).Value(i));
				if (sVar(textfield_script).Value(i) != null_)
					script_execute(self, { sVar(textfield_script).Value(i), (global::_app->setting_unlimited_values > 0) ? snap(val, snapval) : VarType(clamp(snap(val, snapval), minval, maxval)), false });
				else
					fieldupdate = val;
				
			}
			if (sVar(window_busy) != sVar(textfield_name).Value(i) + /*"press"*/ STR(1095) && sVar(window_focus) != string(sVar(textfield_textbox).Value(i)) && fieldupdate == VarType())
				idVar(sVar(textfield_textbox)[i], text) = string_decimals(sVar(textfield_value).Value(i));
			if (vertical > 0)
				fieldy += hei;
			else
				fieldx += fieldwid;
			
		}
		textfield_group_reset(self);
		return fieldupdate;
	}
	
	void draw_texture(VarArgs argument)
	{
		IntType argument_count = argument.Size();
		draw_texture_start();
		if (argument_count < IntType(4))
			draw_texture_part({ argument[IntType(0)], argument[IntType(1)], argument[IntType(2)], IntType(0), IntType(0), texture_width(argument[IntType(0)]), texture_height(argument[IntType(0)]) });
		else
			if (argument_count < IntType(6))
				draw_texture_part({ argument[IntType(0)], argument[IntType(1)], argument[IntType(2)], IntType(0), IntType(0), texture_width(argument[IntType(0)]), texture_height(argument[IntType(0)]), argument[IntType(3)], argument[IntType(4)] });
			else
				draw_texture_part({ argument[IntType(0)], argument[IntType(1)], argument[IntType(2)], IntType(0), IntType(0), texture_width(argument[IntType(0)]), texture_height(argument[IntType(0)]), argument[IntType(3)], argument[IntType(4)], argument[IntType(5)], argument[IntType(6)] });
		
		
		draw_texture_done();
	}
	
	void draw_texture_done()
	{
		texture_set_stage(IntType(0), IntType(0));
		withOne (Object, global::render_shader_obj, noone)
			shader_clear();
		
	}
	
	void draw_texture_part(VarArgs argument)
	{
		IntType argument_count = argument.Size();
		VarType tex, xx, yy, left, top, w, h, xsca, ysca, color;
		RealType alpha;
		tex = argument[IntType(0)];
		xx = argument[IntType(1)];
		yy = argument[IntType(2)];
		left = argument[IntType(3)];
		top = argument[IntType(4)];
		w = argument[IntType(5)];
		h = argument[IntType(6)];
		if (argument_count > IntType(7))
		{
			xsca = argument[IntType(7)];
			ysca = argument[IntType(8)];
		}
		else
		{
			xsca = IntType(1);
			ysca = IntType(1);
		}
		
		if (argument_count > IntType(9))
		{
			color = argument[IntType(9)];
			alpha = draw_get_alpha() * argument[IntType(10)];
		}
		else
		{
			color = c_white;
			alpha = draw_get_alpha();
		}
		
		RealType tw, th;
		tw = texture_width(tex);
		th = texture_height(tex);
		render_set_texture(tex);
		draw_primitive_begin(pr_trianglestrip);
		draw_vertex_texture_color((IntType)(xx), (IntType)(yy), (RealType)left / tw, (RealType)top / th, (IntType)(color), alpha);
		draw_vertex_texture_color((IntType)(xx + w * xsca), (IntType)(yy), (RealType)(left + w) / tw, (RealType)top / th, (IntType)(color), alpha);
		draw_vertex_texture_color((IntType)(xx), (IntType)(yy + h * ysca), (RealType)left / tw, (RealType)(top + h) / th, (IntType)(color), alpha);
		draw_vertex_texture_color((IntType)(xx + w * xsca), (IntType)(yy + h * ysca), (RealType)(left + w) / tw, (RealType)(top + h) / th, (IntType)(color), alpha);
		draw_primitive_end();
		render_set_texture(IntType(0));
	}
	
	void draw_texture_picker(ScopeAny self, VarType select, VarType tex, VarType xx, VarType yy, VarType wid, VarType hei, RealType slots_, RealType slotsx, RealType slotsy, IntType scroll, IntType script, VarType anitex, IntType anislots, VarType anislotsx, VarType anislotsy, VarType res)
	{
		VarType tx, ty;
		RealType off, slotwid, slothei, items, itemwid, itemhei, itemsx, itemsy;
		draw_outline(xx, yy, wid, hei, IntType(1), global::c_border, global::a_border);
		tx = xx;
		ty = yy;
		off = IntType(1);
		if (anitex == null_)
			items = slots_;
		else
			items = slots_ + anislots;
		
		slotwid = clamp(floor(texture_width(tex) / slotsx), IntType(16), IntType(64));
		slothei = clamp(floor(texture_height(tex) / slotsy), IntType(16), IntType(64));
		itemwid = slotwid + (off * IntType(2));
		itemhei = slothei + (off * IntType(2));
		itemsx = floor((wid - IntType(14) * (IntType)ObjType(obj_scrollbar, scroll)->needed) / itemwid);
		itemsy = ceil(items / itemsx);
		for (RealType i = round((RealType)ObjType(obj_scrollbar, scroll)->value / itemhei) * itemsx; i < items; i++)
		{
			VarType col, curtex, curslotsx, curslotsy;
			RealType curslot;
			if (select == i)
				draw_box(tx, ty, slotwid + off * IntType(2), slothei + off * IntType(2), false, global::c_accent_hover, global::a_accent_hover);
			col = c_white;
			if (i < slots_)
			{
				curtex = tex;
				curslot = i;
				curslotsx = slotsx;
				curslotsy = slotsy;
				if (res > 0)
					col = block_texture_get_blend(DsList(ObjType(obj_minecraft_assets, global::mc_assets)->block_texture_list).Value(curslot), res);
			}
			else
			{
				curtex = anitex.Value(block_texture_get_frame(true));
				curslot = i - slots_;
				curslotsx = anislotsx;
				curslotsy = anislotsy;
				if (res > 0)
					col = block_texture_get_blend(DsList(ObjType(obj_minecraft_assets, global::mc_assets)->block_texture_ani_list).Value(curslot), res);
			}
			
			draw_texture_slot(curtex, curslot, tx + off, ty + off, slotwid, slothei, curslotsx, curslotsy, col);
			if (app_mouse_box(self, tx, ty, itemwid, itemhei) && sBool(content_mouseon))
			{
				sInt(mouse_cursor) = cr_handpoint;
				if (sBool(mouse_left_pressed))
				{
					script_execute(self, { script, i });
					sVar(window_focus) = string(scroll);
					select = i;
				}
			}
			tx += itemwid;
			if (tx + itemwid > xx + itemsx * itemwid)
			{
				tx = xx;
				ty += itemhei;
				if (ty + itemhei > yy + hei)
					break;
			}
		}
		ObjType(obj_scrollbar, scroll)->snap_value = itemhei;
		scrollbar_draw(self, scroll, e_scroll_VERTICAL, xx + wid - IntType(12), yy, floor((RealType)hei / itemhei) * itemhei, itemsy * itemhei);
	}
	
	void draw_texture_slot(VarType tex, VarType slot, VarType xx, VarType yy, RealType width, RealType height, VarType slotsx, VarType slotsy, VarType color)
	{
		RealType slotwid, slothei, sx, sy, scale;
		slotwid = max({ IntType(1), texture_width(tex) / slotsx });
		slothei = max({ IntType(1), texture_height(tex) / slotsy });
		sx = (mod(slot, slotsx)) * slotwid;
		sy = ((IntType)(slot / slotsx)) * slothei;
		scale = min({ width / slotwid, height / slothei });
		draw_texture_start();
		draw_texture_part({ tex, xx, yy, sx, sy, slotwid, slothei, scale, scale, color, IntType(1) });
		draw_texture_done();
	}
	
	void draw_texture_start()
	{
		global::render_shader_obj = DsMap(global::shader_map).Value(ID_shader_draw_texture);
		withOne (Object, global::render_shader_obj, noone)
			shader_use(self);
		
	}
	
	RealType draw_togglebutton(ScopeAny self, StringType name, VarType xx, VarType yy, RealType labels, BoolType showcaption)
	{
		RealType h, buttonh, buttoncount, buttonsize;
		VarType w, buttonx, script, scriptvalue, axis;
		BoolType mouseon;
		h = sReal(ui_large_height) + (label_height + IntType(8));
		w = sVar(dw);
		if (xx + w < sVar(content_x) || xx > sVar(content_x) + sVar(content_width) || yy + h < sVar(content_y) || yy > sVar(content_y) + sVar(content_height))
		{
			togglebutton_reset(self);
			return IntType(0);
		}
		if (showcaption)
		{
			draw_set_font(sInt(font_label));
			draw_label(self, { string_limit(text_get({ name }), sVar(dw)), xx, yy - IntType(3), fa_left, fa_top, global::c_text_secondary, global::a_text_secondary });
			yy += (label_height + IntType(8));
		}
		buttonx = xx;
		buttonh = sReal(ui_large_height);
		buttoncount = array_length(VarType::CreateRef(sVar(togglebutton_name)));
		buttonsize = (RealType)w / buttoncount;
		mouseon = false;
		script = null_;
		scriptvalue = null_;
		axis = X_;
		draw_box(xx, yy, w, buttonh, false, global::c_level_top, draw_get_alpha());
		draw_outline(xx, yy, w, buttonh, IntType(1), global::c_border, global::a_border, true);
		for (IntType i = IntType(0); i < buttoncount; i++)
		{
			if (i > IntType(0))
				draw_box(buttonx, yy + IntType(1), IntType(1), buttonh - IntType(2), false, global::c_border, global::a_border);
			buttonx += buttonsize;
		}
		buttonx = xx;
		RealType boxwid;
		for (IntType i = IntType(0); i < buttoncount; i++)
		{
			boxwid = buttonsize;
			if (i < (buttoncount - IntType(1)))
				boxwid += IntType(1);
			mouseon = false;
			if (app_mouse_box(self, buttonx, yy, buttonsize, buttonh) && sBool(content_mouseon))
				mouseon = true;
			if (mouseon)
				sInt(mouse_cursor) = cr_handpoint;
			microani_set(name + sVar(togglebutton_name).Value(i), null_, mouseon, mouseon && sBool(mouse_left), sVar(togglebutton_active).Value(i));
			VarType focus;
			IntType backcolor, linecolor, contentcolor;
			RealType backalpha, linealpha, contentalpha;
			focus = max({ global::microani_arr.Value(e_microani_PRESS), global::microani_arr.Value(e_microani_ACTIVE) });
			backcolor = merge_color(global::c_overlay, (IntType)(global::c_accent_overlay), focus);
			backalpha = lerp(0.0, global::a_overlay, global::microani_arr.Value(e_microani_HOVER));
			backalpha = lerp(backalpha, global::a_accent_overlay, focus);
			backalpha = lerp(backalpha, 0.0, global::microani_arr.Value(e_microani_DISABLED));
			contentcolor = merge_color((IntType)(global::c_text_secondary), (IntType)(global::c_text_main), global::microani_arr.Value(e_microani_HOVER));
			contentcolor = merge_color(contentcolor, (IntType)(global::c_accent), focus);
			contentalpha = lerp(global::a_text_secondary, global::a_text_main, global::microani_arr.Value(e_microani_HOVER));
			contentalpha = lerp(contentalpha, 1.0, focus);
			linecolor = merge_color((IntType)(global::c_border), (IntType)(global::c_text_tertiary), global::microani_arr.Value(e_microani_HOVER));
			linecolor = merge_color(linecolor, (IntType)(global::c_accent), focus);
			linealpha = lerp(0.0, global::a_text_tertiary, global::microani_arr.Value(e_microani_HOVER));
			linealpha = lerp(linealpha, global::a_accent, focus);
			draw_box(buttonx, yy, boxwid, buttonh, false, backcolor, backalpha);
			VarType icon = sVar(togglebutton_icon).Value(i);
			VarType buttonname;
			RealType totalwidth, startx;
			draw_set_font(sInt(font_button));
			buttonname = string_limit(((labels > 0) ? string(text_get({ sVar(togglebutton_name).Value(i) })) : /*""*/ STR(0)), boxwid - IntType(16));
			totalwidth = ((labels > 0) ? string_width(buttonname) : IntType(0)) + (icon == null_ ? IntType(0) : IntType(24) + IntType(8));
			startx = floor(buttonx + (boxwid / 2.0) - (totalwidth / 2.0));
			if (buttonname == /*""*/ STR(0) || !(labels > 0))
			{
				totalwidth = IntType(24);
				startx = floor(buttonx + (boxwid / 2.0) - (totalwidth / 2.0));
			}
			if (icon != null_)
			{
				draw_image({ ID_spr_icons, icon, startx + IntType(12), yy + (buttonh / 2.0), IntType(1), IntType(1), contentcolor, contentalpha });
				startx += IntType(24) + IntType(8);
			}
			if (labels > 0)
			{
				draw_set_font(sInt(font_button));
				draw_label(self, { buttonname, startx, yy + (buttonh / 2.0), fa_left, fa_middle, contentcolor, contentalpha });
			}
			draw_outline(buttonx, yy, boxwid, buttonh, IntType(1), global::c_level_middle, max({ focus, global::microani_arr.Value(e_microani_HOVER) }), true);
			draw_outline(buttonx, yy, boxwid, buttonh, IntType(1), linecolor, linealpha, true);
			draw_box_hover({ buttonx, yy, boxwid, buttonh, global::microani_arr.Value(e_microani_PRESS) });
			microani_update({ mouseon && !sBool(mouse_left), mouseon && sBool(mouse_left), sVar(togglebutton_active).Value(i) });
			if (mouseon && sBool(mouse_left_released))
			{
				if (sVar(togglebutton_script).Value(i) != null_)
				{
					script = sVar(togglebutton_script).Value(i);
					scriptvalue = sVar(togglebutton_value).Value(i);
					axis = sVar(togglebutton_axis).Value(i);
				}
			}
			buttonx += buttonsize;
		}
		buttonx = xx;
		if (script != null_)
		{
			global::axis_edit = axis;
			if (scriptvalue != null_)
				script_execute(self, { script, scriptvalue });
			else
				script_execute(self, { script });
			
			global::axis_edit = X_;
		}
		togglebutton_reset(self);
		return 0.0;
	}
	
	void draw_tooltip_label(ScopeAny self, VarType text, IntType icon, IntType type)
	{
		VarType color;
		color = ObjType(obj_theme, sInt(setting_theme))->toast_color.Value(type);
		draw_set_font(sInt(font_caption));
		text = string_wrap(text_get({ text }), (sVar(dw) - IntType(32)) + IntType(4));
		sVar(dy) -= 8.0;
		tab_control(self, IntType(24) + string_count(/*"\n"*/ STR(979), text) * IntType(14));
		draw_image({ ID_spr_icons, icon, sVar(dx) + IntType(12), sVar(dy) + (sReal(tab_control_h) / 2.0), IntType(1), IntType(1), color, IntType(1) });
		draw_label(self, { text, sVar(dx) + IntType(32), sVar(dy) + (sReal(tab_control_h) / 2.0), fa_left, fa_middle, global::c_text_secondary, global::a_text_secondary, sInt(font_caption) });
		tab_next(self);
	}
	
	RealType draw_wheel(ScopeAny self, StringType name, VarType xx, VarType yy, VarType color, VarType value, RealType minval, RealType maxval, VarType def, RealType snapval, VarType tbx, IntType script, RealType rad, VarType sprite)
	{
		if (xx + rad < sVar(content_x) || xx - rad > sVar(content_x) + sVar(content_width) || yy + rad < sVar(content_y) || yy - rad > sVar(content_y) + sVar(content_height))
			return IntType(0);
		if (is_undefined(sprite))
			sprite = ID_spr_control_dial;
		RealType modval, labelx, labelw, labeltextw;
		IntType capwid;
		StringType text;
		VarType labely;
		context_menu_area(self, { xx - rad, yy - rad, rad * IntType(2), rad * IntType(2), /*"contextmenuvalue"*/ STR(1087), value, e_context_type_NUMBER, script, def });
		draw_set_font(sInt(font_label));
		modval = mod_fix(value, IntType(360));
		capwid = string_width(text_get({ name }) + /*":"*/ STR(793)) + IntType(5);
		text = string_decimals(value) + ObjType(obj_textbox, tbx)->suffix;
		draw_set_font(sInt(font_digits));
		labelw = rad;
		labeltextw = capwid + string_width(text);
		labelx = xx - (labeltextw / 2.0) + capwid;
		labely = yy + IntType(36);
		draw_image({ sprite, IntType(0), xx, yy, IntType(1), IntType(1), global::c_border, global::a_border });
		gpu_set_tex_filter(true);
		draw_image({ ID_spr_dial_dash, IntType(0), xx, yy, .5, .5, color, IntType(1), value + IntType(45) });
		gpu_set_tex_filter(false);
		if (sVar(window_busy) == name)
		{
			sInt(mouse_cursor) = cr_handpoint;
			RealType angle1, angle2;
			VarType newval;
			angle1 = point_direction(xx, yy, gmlGlobal::mouse_x, gmlGlobal::mouse_y);
			angle2 = point_direction(xx, yy, sVar(mouse_previous_x), sVar(mouse_previous_y));
			sVar(wheel_drag_value) += angle_difference_fix(angle1, angle2) * sReal(dragger_multiplier);
			if (global::_app->setting_unlimited_values > 0)
				newval = snap(sVar(wheel_drag_value), snapval);
			else
				newval = clamp(snap(sVar(wheel_drag_value), snapval), minval, maxval);
			
			script_execute(self, { script, newval - value, true });
			if (!sBool(mouse_left))
			{
				sVar(window_busy) = /*""*/ STR(0);
				app_mouse_clear(self);
			}
		}
		if (app_mouse_box(self, xx - rad, yy - rad, rad * IntType(2), rad * IntType(2)) && sBool(content_mouseon))
		{
			sInt(mouse_cursor) = cr_handpoint;
			if (sBool(mouse_left_pressed))
			{
				RealType newval = clamp(snap(value + angle_difference_fix(point_direction(xx, yy, gmlGlobal::mouse_x, gmlGlobal::mouse_y), value), snapval), minval, maxval);
				script_execute(self, { script, newval - value, true });
				sVar(window_focus) = name;
				sVar(window_busy) = name;
				sVar(wheel_drag_value) = newval;
			}
		}
		return 0.0;
	}
	
	RealType draw_wheel_sky(ScopeAny self, StringType name, VarType xx, VarType yy, VarType value, RealType def, IntType script, IntType tbx, RealType time)
	{
		RealType rad, sunx, suny, moonx, moony;
		BoolType mouseon, sunmouseon, moonmouseon;
		if (sBool(textbox_jump))
			ds_list_add({ sInt(textbox_list), ArrType::From({ tbx, sVar(content_tab), yy, sVar(content_y), sVar(content_height) }) });
		rad = IntType(49);
		if (xx + rad < sVar(content_x) || xx - rad > sVar(content_x) + sVar(content_width) || yy + rad < sVar(content_y) || yy - rad > sVar(content_y) + sVar(content_height))
			return IntType(0);
		mouseon = app_mouse_box(self, xx - rad, yy - rad, rad * IntType(2), rad * IntType(2)) && sBool(content_mouseon);
		context_menu_area(self, { xx - (rad + IntType(10)), yy - (rad + IntType(10)), (rad + IntType(10)) * IntType(2), (rad + IntType(10)) * IntType(2), /*"contextmenuvalue"*/ STR(1087), value, (time > 0) ? e_context_type_TIME : e_context_type_NUMBER, script, def });
		microani_set(name, script, mouseon, (sVar(window_busy) == name && !(sVar(wheel_drag_moon) > 0)), (sVar(window_focus) == string(tbx)), (sVar(window_busy) == name && sVar(wheel_drag_moon) > 0));
		VarType active;
		IntType color;
		RealType alpha;
		active = min({ IntType(1), global::microani_arr.Value(e_microani_PRESS) + global::microani_arr.Value(e_microani_ACTIVE) + global::microani_arr.Value(e_microani_DISABLED) });
		color = merge_color((IntType)(global::c_text_tertiary), (IntType)(global::c_text_secondary), min({ IntType(1), global::microani_arr.Value(e_microani_HOVER) + active }));
		alpha = lerp(global::a_text_tertiary, global::a_text_secondary, min({ IntType(1), global::microani_arr.Value(e_microani_HOVER) + active }));
		draw_image({ ID_spr_circle_96, IntType(0), xx, yy, IntType(1), IntType(1), color, alpha });
		color = merge_color((IntType)(global::c_text_secondary), (IntType)(global::c_text_main), global::microani_arr.Value(e_microani_HOVER));
		color = merge_color(color, (IntType)(global::c_accent), active);
		alpha = lerp(global::a_text_secondary, global::a_text_main, global::microani_arr.Value(e_microani_HOVER));
		alpha = lerp(alpha, 1.0, active);
		draw_label(self, { text_get({ name }), xx, yy - IntType(4), fa_center, fa_bottom, color, alpha, sInt(font_label) });
		color = merge_color((IntType)(global::c_text_secondary), (IntType)(global::c_text_main), global::microani_arr.Value(e_microani_PRESS));
		color = merge_color(color, (IntType)(global::c_accent), global::microani_arr.Value(e_microani_PRESS));
		alpha = lerp(global::a_text_secondary, global::a_text_main, global::microani_arr.Value(e_microani_PRESS));
		alpha = lerp(alpha, 1.0, global::microani_arr.Value(e_microani_PRESS));
		sunx = floor(xx + lengthdir_x(rad, value + 90.0));
		suny = floor(yy + lengthdir_y(rad, value + 90.0));
		sunmouseon = (app_mouse_box(self, sunx - IntType(10), suny - IntType(10), IntType(20), IntType(20)) && sBool(content_mouseon));
		draw_circle_ext(sunx, suny, IntType(14), false, IntType(16), global::c_level_middle, IntType(1));
		draw_image({ ID_spr_icons, icons_SUN, sunx, suny, IntType(1), IntType(1), color, alpha });
		color = merge_color((IntType)(global::c_text_secondary), (IntType)(global::c_text_main), global::microani_arr.Value(e_microani_DISABLED));
		color = merge_color(color, (IntType)(global::c_accent), global::microani_arr.Value(e_microani_DISABLED));
		alpha = lerp(global::a_text_secondary, global::a_text_main, global::microani_arr.Value(e_microani_DISABLED));
		alpha = lerp(alpha, 1.0, global::microani_arr.Value(e_microani_DISABLED));
		moonx = floor(xx + lengthdir_x(rad, value - IntType(90)));
		moony = floor(yy + lengthdir_y(rad, value - IntType(90)));
		moonmouseon = (app_mouse_box(self, moonx - IntType(10), moony - IntType(10), IntType(20), IntType(20)) && sBool(content_mouseon));
		draw_circle_ext(moonx, moony, IntType(14), false, IntType(16), global::c_level_middle, IntType(1));
		draw_image({ ID_spr_icons, icons_MOON, moonx, moony, IntType(1), IntType(1), color, alpha });
		microani_update({ mouseon || sunmouseon || moonmouseon, (sVar(window_busy) == name && !(sVar(wheel_drag_moon) > 0)), (sVar(window_focus) == string(tbx)), (sVar(window_busy) == name && sVar(wheel_drag_moon) > 0) });
		if (sunmouseon || moonmouseon)
		{
			sInt(mouse_cursor) = cr_handpoint;
			if (sBool(mouse_left_pressed))
			{
				sVar(window_focus) = name;
				sVar(window_busy) = name;
				sVar(wheel_drag_moon) = moonmouseon;
				if (!(sVar(wheel_drag_moon) > 0))
				{
					RealType add = angle_difference_fix(point_direction(xx, yy, gmlGlobal::mouse_x, gmlGlobal::mouse_y) - IntType(90), value);
					script_execute(self, { script, add, true });
				}
			}
		}
		if (sVar(window_busy) == name)
		{
			RealType angle1, angle2, add;
			sInt(mouse_cursor) = cr_handpoint;
			angle1 = point_direction(xx, yy, gmlGlobal::mouse_x, gmlGlobal::mouse_y) - IntType(90);
			angle2 = point_direction(xx, yy, sVar(mouse_previous_x), sVar(mouse_previous_y)) - IntType(90);
			add = angle_difference_fix(angle1, angle2);
			script_execute(self, { script, add, true });
			if (!sBool(mouse_left))
			{
				sVar(window_busy) = /*""*/ STR(0);
				app_mouse_clear(self);
			}
		}
		draw_set_font(sInt(font_value));
		VarType label;
		RealType labelw, labelx;
		if (time > 0)
			label = (sVar(window_focus) == string(tbx) ? ObjType(obj_textbox, tbx)->text : rotation_get_time(value));
		else
			label = (sVar(window_focus) == string(tbx) ? ObjType(obj_textbox, tbx)->text : VarType((string(value) + ObjType(obj_textbox, tbx)->suffix)));
		
		labelw = string_width(label);
		labelx = xx - labelw / 2.0;
		if (sVar(window_focus) == string(tbx))
		{
			if (textbox_draw(self, tbx, labelx, yy + IntType(4), labelw, IntType(18)))
			{
				if (time > 0)
					script_execute(self, { script, time_get_rotation(ObjType(obj_textbox, tbx)->text), false });
				else
					script_execute(self, { script, clamp(string_get_real(ObjType(obj_textbox, tbx)->text, IntType(0)), -no_limit, no_limit), false });
				
			}
		}
		else
			draw_label(self, { label, labelx, yy + IntType(4), fa_left, fa_top, global::c_text_main, global::a_text_main, sInt(font_value) });
		
		if (app_mouse_box(self, labelx, yy + IntType(4), labelw, IntType(16)))
		{
			sInt(mouse_cursor) = cr_handpoint;
			if (sBool(mouse_left_pressed))
			{
				if (time > 0)
					ObjType(obj_textbox, tbx)->text = rotation_get_time(value);
				else
					ObjType(obj_textbox, tbx)->text = string(value);
				
				sVar(window_focus) = string(tbx);
			}
		}
		return 0.0;
	}
	
	ArrType ds_list_create_array(VarType list)
	{
		ArrType arr = ArrType();
		for (IntType i = IntType(0); i < ds_list_size((IntType)(list)); i++)
		{
			if (is_array(DsList(list).Value(i)))
				array_add(VarType::CreateRef(arr), array_copy_1d(DsList(list).Value(i)), false);
			else
				array_add(VarType::CreateRef(arr), DsList(list).Value(i), false);
			
		}
		return arr;
	}
	
	void ds_list_delete_value(IntType list, VarType val)
	{
		IntType index = ds_list_find_index(list, val);
		if (index >= IntType(0))
			ds_list_delete(list, index);
	}
	
	void ds_list_merge(IntType list, VarType src)
	{
		for (IntType i = IntType(0); i < ds_list_size((IntType)(src)); i++)
			ds_list_add({ list, DsList(src).Value(i) });
	}
	
	BoolType ds_list_valid(VarType list)
	{
		return (is_real(list) && ds_exists(list, ds_type_list));
	}
	
	VarType ds_map_find_key(IntType map, VarType val)
	{
		VarType key = ds_map_find_first(map);
		while (!is_undefined(key))
		{
			if (DsMap(map).Value(key) == val)
				return key;
			key = ds_map_find_next(map, key);
		}
		
		return VarType();
	}
	
	void ds_map_merge(VarType map, VarType source, BoolType overwrite)
	{
		VarType key = ds_map_find_first((IntType)(source));
		while (!is_undefined(key))
		{
			if (overwrite || is_undefined(DsMap(map).Value(key)))
				DsMap(map)[key] = DsMap(source).Value(key);
			key = ds_map_find_next((IntType)(source), key);
		}
		
	}
	
	BoolType ds_map_valid(VarType map)
	{
		return (is_real(map) && ds_exists(map, ds_type_map));
	}
	
	VarType ease(VarType func, VarType xx)
	{
		RealType xx2, xxm1;
		xx2 = xx * IntType(2);
		xxm1 = xx - IntType(1);
		if (xx <= IntType(0))
			return IntType(0);
		if (xx >= IntType(1))
			return IntType(1);
		switch (StringType(func).id)
		{
			case 542: // linear
			{
				return xx;
			}
			case 543: // instant
			{
				return IntType(0);
			}
			case 545: // easeinquad
			{
				return xx * xx;
			}
			case 546: // easeoutquad
			{
				return -xx * (xx - IntType(2));
			}
			case 547: // easeinoutquad
			{
				if (xx2 < IntType(1))
					return 1.0 / IntType(2) * xx2 * xx2;
				return -1.0 / IntType(2) * ((xx2 - IntType(1)) * (xx2 - IntType(3)) - IntType(1));
			}
			case 548: // easeincubic
			{
				return xx * xx * xx;
			}
			case 549: // easeoutcubic
			{
				return ((xxm1) * xxm1 * xxm1 + IntType(1));
			}
			case 550: // easeinoutcubic
			{
				if (xx2 < IntType(1))
					return 1.0 / IntType(2) * xx2 * xx2 * xx2;
				return 1.0 / IntType(2) * ((xx2 - IntType(2)) * (xx2 - IntType(2)) * (xx2 - IntType(2)) + IntType(2));
			}
			case 551: // easeinquart
			{
				return xx * xx * xx * xx;
			}
			case 552: // easeoutquart
			{
				return -((xxm1) * xxm1 * xxm1 * xxm1 - IntType(1));
			}
			case 553: // easeinoutquart
			{
				if (xx2 < IntType(1))
					return 1.0 / IntType(2) * xx2 * xx2 * xx2 * xx2;
				return -1.0 / IntType(2) * ((xx2 - IntType(2)) * (xx2 - IntType(2)) * (xx2 - IntType(2)) * (xx2 - IntType(2)) - IntType(2));
			}
			case 554: // easeinquint
			{
				return xx * xx * xx * xx * xx;
			}
			case 555: // easeoutquint
			{
				return ((xxm1) * xxm1 * xxm1 * xxm1 * xxm1 + IntType(1));
			}
			case 556: // easeinoutquint
			{
				if (xx2 < IntType(1))
					return 1.0 / IntType(2) * xx2 * xx2 * xx2 * xx2 * xx2;
				return 1.0 / IntType(2) * ((xx2 - IntType(2)) * (xx2 - IntType(2)) * (xx2 - IntType(2)) * (xx2 - IntType(2)) * (xx2 - IntType(2)) + IntType(2));
			}
			case 557: // easeinsine
			{
				return -cos(xx * (pi_ / 2.0)) + IntType(1);
			}
			case 558: // easeoutsine
			{
				return sin(xx * (pi_ / 2.0));
			}
			case 559: // easeinoutsine
			{
				return -1.0 / IntType(2) * (cos(pi_ * (RealType)xx / 1.0) - IntType(1));
			}
			case 560: // easeinexpo
			{
				return power(2.0, IntType(10) * (xx - IntType(1)));
			}
			case 561: // easeoutexpo
			{
				return -power(2.0, -IntType(10) * xx) + IntType(1);
			}
			case 562: // easeinoutexpo
			{
				if (xx2 < IntType(1))
					return 1.0 / IntType(2) * power(2.0, IntType(10) * (xx2 - IntType(1)));
				return 1.0 / IntType(2) * (-power(2.0, -IntType(10) * (xx2 - IntType(1))) + IntType(2));
			}
			case 563: // easeincirc
			{
				return -(sqrt(IntType(1) - xx * xx) - IntType(1));
			}
			case 564: // easeoutcirc
			{
				return sqrt(IntType(1) - (xxm1) * xxm1);
			}
			case 565: // easeinoutcirc
			{
				if (xx2 < IntType(1))
					return -1.0 / IntType(2) * (sqrt(IntType(1) - xx2 * xx2) - IntType(1));
				return 1.0 / IntType(2) * (sqrt(max({ IntType(0), IntType(1) - (xx2 - IntType(2)) * (xx2 - IntType(2)) })) + IntType(1));
			}
			case 566: // easeinelastic
			{
				RealType p = 0.3;
				RealType s = p / (IntType(2) * pi_) * arcsin(1.0);
				return -(power(2.0, IntType(10) * (xx - IntType(1))) * sin(((xx - IntType(1)) * IntType(1) - s) * (IntType(2) * pi_) / p));
			}
			case 567: // easeoutelastic
			{
				RealType p = 0.3;
				RealType s = p / (IntType(2) * pi_) * arcsin(1.0);
				return power(2.0, -IntType(10) * xx) * sin((xx * IntType(1) - s) * (IntType(2) * pi_) / p) + IntType(1);
			}
			case 568: // easeinoutelastic
			{
				RealType p = 0.3 * 1.5;
				RealType s = p / (IntType(2) * pi_) * arcsin(1.0);
				if (xx2 < IntType(1))
					return -0.5 * (power(2.0, IntType(10) * (xx2 - IntType(1))) * sin(((xx2 - IntType(1)) * IntType(1) - s) * (IntType(2) * pi_) / p));
				return power(2.0, -IntType(10) * (xx2 - IntType(1))) * sin(((xx2 - IntType(1)) * IntType(1) - s) * (IntType(2) * pi_) / p) * 0.5 + IntType(1);
			}
			case 569: // easeinback
			{
				RealType s = 1.70158;
				return xx * xx * ((s + IntType(1)) * xx - s);
			}
			case 570: // easeoutback
			{
				RealType s = 1.70158;
				return (xxm1 * xxm1 * ((s + IntType(1)) * xxm1 + s) + IntType(1));
			}
			case 571: // easeinoutback
			{
				RealType s = 1.70158;
				if (xx2 < IntType(1))
					return 1.0 / IntType(2) * (xx2 * xx2 * (((s * (1.525)) + IntType(1)) * xx2 - (s * (1.525))));
				return 1.0 / IntType(2) * ((xx2 - IntType(2)) * (xx2 - IntType(2)) * (((s * (1.525)) + IntType(1)) * (xx2 - IntType(2)) + (s * (1.525))) + IntType(2));
			}
			case 572: // easeinbounce
			{
				xx = IntType(1) - xx;
				if (xx < (1.0 / 2.75))
					return IntType(1) - (7.5625 * xx * xx);
				else
					if (xx < (2.0 / 2.75))
						return IntType(1) - (7.5625 * (xx - (1.5 / 2.75)) * (xx - (1.5 / 2.75)) + 0.75);
					else
						if (xx < (2.5 / 2.75))
							return IntType(1) - (7.5625 * (xx - (2.25 / 2.75)) * (xx - (2.25 / 2.75)) + 0.9375);
						else
							return IntType(1) - (7.5625 * (xx - (2.625 / 2.75)) * (xx - (2.625 / 2.75)) + 0.984375);
					
				
				
			}
			
			case 573: // easeoutbounce
			{
				if (xx < (1.0 / 2.75))
					return (7.5625 * xx * xx);
				else
					if (xx < (2.0 / 2.75))
						return (7.5625 * (xx - (1.5 / 2.75)) * (xx - (1.5 / 2.75)) + 0.75);
					else
						if (xx < (2.5 / 2.75))
							return (7.5625 * (xx - (2.25 / 2.75)) * (xx - (2.25 / 2.75)) + 0.9375);
						else
							return (7.5625 * (xx - (2.625 / 2.75)) * (xx - (2.625 / 2.75)) + 0.984375);
					
				
				
			}
			
			case 574: // easeinoutbounce
			{
				RealType ret;
				if (xx < 1.0 / 2.0)
				{
					xx *= 2.0;
					xx = IntType(1) - xx;
					if (xx < (1.0 / 2.75))
						ret = (7.5625 * xx * xx);
					else
						if (xx < (2.0 / 2.75))
							ret = (7.5625 * (xx - (1.5 / 2.75)) * (xx - (1.5 / 2.75)) + 0.75);
						else
							if (xx < (2.5 / 2.75))
								ret = (7.5625 * (xx - (2.25 / 2.75)) * (xx - (2.25 / 2.75)) + 0.9375);
							else
								ret = (7.5625 * (xx - (2.625 / 2.75)) * (xx - (2.625 / 2.75)) + 0.984375);
						
					
					
					ret = IntType(1) - ret;
					ret *= .5;
				}
				else
				{
					xx = xx * IntType(2) - IntType(1);
					if (xx < (1.0 / 2.75))
						ret = (7.5625 * xx * xx);
					else
						if (xx < (2.0 / 2.75))
							ret = (7.5625 * (xx - (1.5 / 2.75)) * (xx - (1.5 / 2.75)) + 0.75);
						else
							if (xx < (2.5 / 2.75))
								ret = (7.5625 * (xx - (2.25 / 2.75)) * (xx - (2.25 / 2.75)) + 0.9375);
							else
								ret = (7.5625 * (xx - (2.625 / 2.75)) * (xx - (2.625 / 2.75)) + 0.984375);
						
					
					
					ret *= 0.5;
					ret += 0.5;
				}
				
				return ret;
			}
			
		}
		
		return xx;
	}
	
}
