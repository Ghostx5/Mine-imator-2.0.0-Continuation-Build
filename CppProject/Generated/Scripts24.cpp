/*
	NOTE:
	This file was autogenerated by CppGen, changes may be overwritten and forever lost!
	Modify at your own risk!
	
	[ Generated on 2023.06.16 19:54:52 ]
*/

#include "Scripts.hpp"

namespace CppProject
{
	void buffer_skip(RealType bytes)
	{
		buffer_seek(global::buffer_current, buffer_seek_relative, (IntType)(bytes));
	}
	
	void buffer_write_byte(VarType val)
	{
		buffer_write(global::buffer_current, buffer_u8, val);
	}
	
	void buffer_write_double(VarType val)
	{
		buffer_write(global::buffer_current, buffer_f64, val);
	}
	
	void buffer_write_double_be(VarType val)
	{
		IntType tmpbuf;
		ArrType byte;
		tmpbuf = buffer_create(IntType(8), buffer_fixed, IntType(1));
		buffer_write(tmpbuf, buffer_f64, val);
		buffer_seek(tmpbuf, IntType(0), IntType(0));
		for (IntType b = IntType(0); b < IntType(8); b++)
			byte[b] = buffer_read(tmpbuf, buffer_s8);
		buffer_delete(tmpbuf);
		for (IntType b = IntType(0); b < IntType(8); b++)
			buffer_write_byte(byte.Value(IntType(7) - b));
	}
	
	void buffer_write_float_be(VarType val)
	{
		IntType tmpbuf;
		ArrType byte;
		tmpbuf = buffer_create(IntType(4), buffer_fixed, IntType(1));
		buffer_write(tmpbuf, buffer_f32, val);
		buffer_seek(tmpbuf, IntType(0), IntType(0));
		for (IntType b = IntType(0); b < IntType(4); b++)
			byte[b] = buffer_read(tmpbuf, buffer_s8);
		buffer_delete(tmpbuf);
		for (IntType b = IntType(0); b < IntType(4); b++)
			buffer_write_byte(byte.Value(IntType(3) - b));
	}
	
	void buffer_write_int(IntType val)
	{
		buffer_write(global::buffer_current, buffer_s32, val);
	}
	
	void buffer_write_short(VarType val)
	{
		buffer_write(global::buffer_current, buffer_u16, val);
	}
	
	void buffer_write_string_int(StringType str)
	{
		IntType len = string_length(str);
		buffer_write_int(len);
		for (IntType p = IntType(0); p < len; p++)
			buffer_write_byte(ord(string_char_at(str, p + IntType(1))));
	}
	
	void builder_combine_threads(Scope<obj_builder> self)
	{
		for (IntType t = IntType(0); t < ds_list_size(self->thread_list); t++)
		{
			withOne (obj_builder_thread, DsList(self->thread_list).Value(t), self->id)
			{
				if (self->block_multithreaded_skip)
					ObjType(obj_builder, self.otherId)->block_multithreaded_skip = true;
				if (self->block_tl_map != null_)
				{
					VarType key = ds_map_find_first(self->block_tl_map);
					while (!is_undefined(key))
					{
						VarType arr = DsMap(self->block_tl_map).Value(key);
						builder_thread_set_pos(self, key);
						ds_list_add({ ObjType(obj_builder, self.otherId)->block_tl_list, block_get_timeline(self, arr.Value(IntType(0)), arr.Value(IntType(1))) });
						key = ds_map_find_next(self->block_tl_map, key);
					}
					
					ds_map_destroy(self->block_tl_map);
				}
				VarType key = ds_map_find_first(self->block_render_model_multipart_map);
				while (!is_undefined(key))
				{
					builder_thread_set_pos(self, key);
					builder_add_render_model_multi_part(self, self->build_pos_x, self->build_pos_y, self->build_pos_z, DsMap(self->block_render_model_multipart_map).Value(key));
					key = ds_map_find_next(self->block_render_model_multipart_map, key);
				}
				
				ds_map_destroy(self->block_render_model_multipart_map);
				instance_destroy(ScopeAny(self));
			}
			
		}
		if (ds_list_size(self->thread_list) > IntType(1))
			thread_task_end();
		ds_list_clear(self->thread_list);
	}
	
	void builder_event_create(Scope<obj_builder> self)
	{
		self->sch_palette_blocks = null_;
		self->sch_palette_stateids = null_;
		self->sch_palette_waterlogged = null_;
		self->sch_blockdata_array = null_;
		self->sch_blockdata_ints = false;
		self->sch_legacy_blocksarray = null_;
		self->sch_legacy_dataarray = null_;
		self->sch_timeline_amount = IntType(0);
		self->sch_tileentity_list = null_;
		self->build_size = vec3(IntType(0), IntType(0), IntType(0));
		self->build_size_x = IntType(0);
		self->build_size_y = IntType(0);
		self->build_size_xy = IntType(0);
		self->build_size_z = IntType(0);
		self->build_size_total = IntType(0);
		self->build_size_sqrt = IntType(0);
		self->build_pos_x = IntType(0);
		self->build_pos_y = IntType(0);
		self->build_pos_z = IntType(0);
		self->build_edge_xp = false;
		self->build_edge_xn = false;
		self->build_edge_yp = false;
		self->build_edge_yn = false;
		self->build_edge_zp = false;
		self->build_edge_zn = false;
		self->build_edges = true;
		self->build_single_block = null_;
		self->build_single_stateid = IntType(0);
		self->build_multithreaded = null_;
		self->build_randomize = false;
		self->block_obj = null_;
		self->block_waterlogged = null_;
		self->block_current = IntType(0);
		self->block_state_id = null_;
		self->block_state_id_current = IntType(0);
		self->block_render_model = null_;
		self->block_text_front_map = ds_int_map_create();
		self->block_text_front_color_map = ds_int_map_create();
		self->block_text_front_glow_color_map = ds_int_map_create();
		self->block_text_front_glowing_map = ds_int_map_create();
		self->block_text_back_map = ds_int_map_create();
		self->block_text_back_color_map = ds_int_map_create();
		self->block_text_back_glow_color_map = ds_int_map_create();
		self->block_text_back_glowing_map = ds_int_map_create();
		self->block_banner_color_map = ds_int_map_create();
		self->block_banner_patterns_map = ds_int_map_create();
		self->block_banner_pattern_colors_map = ds_int_map_create();
		self->block_skull_map = ds_int_map_create();
		self->block_skull_res_map = ds_map_create();
		self->block_skull_texture_map = ds_string_map_create();
		self->block_skull_texture_fail = false;
		self->block_skull_texture_name = /*""*/ STR(0);
		self->block_skull_texture = null_;
		self->block_skull_download_time = IntType(0);
		self->block_skull_download_wait = false;
		self->block_skull_texture_count = IntType(0);
		self->block_skull_finish_count = IntType(0);
		self->block_skull_fail_count = IntType(0);
		self->block_decorated_pot_sherds_map = ds_int_map_create();
		self->block_multithreaded_skip = false;
		self->block_tl_add = false;
		self->block_tl_list = null_;
		self->block_color = null_;
		self->file_map = /*""*/ STR(0);
		self->builder_scenery = false;
		self->builder_scenery_legacy = false;
		self->thread_list = ds_list_create();
	}
	
	RealType builder_generate(ScopeAny self)
	{
		sInt(block_current) = builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y), sInt(build_pos_z));
		if (sInt(block_current) == null_)
			return IntType(0);
		if (ObjType(obj_builder, global::mc_builder)->build_multithreaded != null_)
		{
			if (idVar(sInt(block_current), multithreaded) != ObjType(obj_builder, global::mc_builder)->build_multithreaded)
			{
				sBool(block_multithreaded_skip) = true;
				return IntType(0);
			}
		}
		sBool(build_edge_xp) = (sInt(build_pos_x) == sInt(build_size_x) - IntType(1));
		sBool(build_edge_xn) = (sInt(build_pos_x) == IntType(0));
		sBool(build_edge_yp) = (sInt(build_pos_y) == sInt(build_size_y) - IntType(1));
		sBool(build_edge_yn) = (sInt(build_pos_y) == IntType(0));
		sBool(build_edge_zp) = (sInt(build_pos_z) == sInt(build_size_z) - IntType(1));
		sBool(build_edge_zn) = (sInt(build_pos_z) == IntType(0));
		sBool(block_face_full_xp) = false;
		sInt(block_face_min_depth_xp) = null_;
		if (sBool(build_edge_xp))
		{
			if (!ObjType(obj_builder, global::mc_builder)->build_edges)
			{
				sBool(block_face_full_xp) = true;
				sInt(block_face_min_depth_xp) = e_block_depth_DEPTH0;
			}
		}
		else
		{
			IntType othermodel = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x) + IntType(1), sInt(build_pos_y), sInt(build_pos_z));
			if (othermodel != null_)
			{
				sBool(block_face_full_xp) = idBool(othermodel, face_full_xn);
				sVar(block_face_min_xp) = idVar(othermodel, face_min_xn);
				sVar(block_face_max_xp) = idVar(othermodel, face_max_xn);
				sInt(block_face_min_depth_xp) = idInt(othermodel, face_min_depth_xn);
			}
		}
		
		sBool(block_face_full_xn) = false;
		sInt(block_face_min_depth_xn) = null_;
		if (sBool(build_edge_xn))
		{
			if (!ObjType(obj_builder, global::mc_builder)->build_edges)
			{
				sBool(block_face_full_xn) = true;
				sInt(block_face_min_depth_xn) = e_block_depth_DEPTH0;
			}
		}
		else
		{
			IntType othermodel = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x) - IntType(1), sInt(build_pos_y), sInt(build_pos_z));
			if (othermodel != null_)
			{
				sBool(block_face_full_xn) = idBool(othermodel, face_full_xp);
				sVar(block_face_min_xn) = idVar(othermodel, face_min_xp);
				sVar(block_face_max_xn) = idVar(othermodel, face_max_xp);
				sInt(block_face_min_depth_xn) = idInt(othermodel, face_min_depth_xp);
			}
		}
		
		sBool(block_face_full_yp) = false;
		sInt(block_face_min_depth_yp) = null_;
		if (sBool(build_edge_yp))
		{
			if (!ObjType(obj_builder, global::mc_builder)->build_edges)
			{
				sBool(block_face_full_yp) = true;
				sInt(block_face_min_depth_yp) = e_block_depth_DEPTH0;
			}
		}
		else
		{
			IntType othermodel = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y) + IntType(1), sInt(build_pos_z));
			if (othermodel != null_)
			{
				sBool(block_face_full_yp) = idBool(othermodel, face_full_yn);
				sVar(block_face_min_yp) = idVar(othermodel, face_min_yn);
				sVar(block_face_max_yp) = idVar(othermodel, face_max_yn);
				sInt(block_face_min_depth_yp) = idInt(othermodel, face_min_depth_yn);
			}
		}
		
		sBool(block_face_full_yn) = false;
		sInt(block_face_min_depth_yn) = null_;
		if (sBool(build_edge_yn))
		{
			if (!ObjType(obj_builder, global::mc_builder)->build_edges)
			{
				sBool(block_face_full_yn) = true;
				sInt(block_face_min_depth_yn) = e_block_depth_DEPTH0;
			}
		}
		else
		{
			IntType othermodel = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y) - IntType(1), sInt(build_pos_z));
			if (othermodel != null_)
			{
				sBool(block_face_full_yn) = idBool(othermodel, face_full_yp);
				sVar(block_face_min_yn) = idVar(othermodel, face_min_yp);
				sVar(block_face_max_yn) = idVar(othermodel, face_max_yp);
				sInt(block_face_min_depth_yn) = idInt(othermodel, face_min_depth_yp);
			}
		}
		
		sBool(block_face_full_zp) = false;
		sInt(block_face_min_depth_zp) = null_;
		if (!sBool(build_edge_zp))
		{
			IntType othermodel = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y), sInt(build_pos_z) + IntType(1));
			if (othermodel != null_)
			{
				sBool(block_face_full_zp) = idBool(othermodel, face_full_zn);
				sVar(block_face_min_zp) = idVar(othermodel, face_min_zn);
				sVar(block_face_max_zp) = idVar(othermodel, face_max_zn);
				sInt(block_face_min_depth_zp) = idInt(othermodel, face_min_depth_zn);
			}
		}
		sBool(block_face_full_zn) = false;
		sInt(block_face_min_depth_zn) = null_;
		if (sBool(build_edge_zn))
		{
			if (!ObjType(obj_builder, global::mc_builder)->build_edges)
			{
				sBool(block_face_full_zn) = true;
				sInt(block_face_min_depth_zn) = e_block_depth_DEPTH0;
			}
		}
		else
		{
			IntType othermodel = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y), sInt(build_pos_z) - IntType(1));
			if (othermodel != null_)
			{
				sBool(block_face_full_zn) = idBool(othermodel, face_full_zp);
				sVar(block_face_min_zn) = idVar(othermodel, face_min_zp);
				sVar(block_face_max_zn) = idVar(othermodel, face_max_zp);
				sInt(block_face_min_depth_zn) = idInt(othermodel, face_min_depth_zp);
			}
		}
		
		if (sInt(block_face_min_depth_xp) == e_block_depth_DEPTH0 && sBool(block_face_full_xp) && sInt(block_face_min_depth_xn) == e_block_depth_DEPTH0 && sBool(block_face_full_xn) && sInt(block_face_min_depth_yp) == e_block_depth_DEPTH0 && sBool(block_face_full_yp) && sInt(block_face_min_depth_yn) == e_block_depth_DEPTH0 && sBool(block_face_full_yn) && sInt(block_face_min_depth_zp) == e_block_depth_DEPTH0 && sBool(block_face_full_zp) && sInt(block_face_min_depth_zn) == e_block_depth_DEPTH0 && sBool(block_face_full_zn))
			return IntType(0);
		sReal(block_state_id_current) = builder_get_state_id(self, sInt(build_pos_x), sInt(build_pos_y), sInt(build_pos_z));
		sInt(block_pos_x) = sInt(build_pos_x) * block_size_;
		sInt(block_pos_y) = sInt(build_pos_y) * block_size_;
		sInt(block_pos_z) = sInt(build_pos_z) * block_size_;
		sInt(block_color) = null_;
		if (idInt(sInt(block_current), generate_script) > -IntType(1))
			script_execute(self, { idInt(sInt(block_current), generate_script) });
		else
		{
			VarType model = null_;
			if (idVar(sInt(block_current), require_models) > 0)
				model = builder_set_model(self, true);
			else
			{
				IntType modelindex = builder_get_render_model_index(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y), sInt(build_pos_z));
				if (modelindex > IntType(0))
					model = modelindex;
				else
					if (modelindex < IntType(0))
						model = builder_get_render_model_multipart(sInt(build_pos_x), sInt(build_pos_y), sInt(build_pos_z), -modelindex);
				
			}
			
			IntType singlemodel = null_;
			if (is_array(model))
				singlemodel = global::block_rendermodels.Value(model.Value(IntType(0)));
			else
				if (model > IntType(0))
					singlemodel = global::block_rendermodels.Value(model);
			
			if (singlemodel != null_)
			{
				if ((ObjType(obj_block_render_model, singlemodel)->random_offset > 0 && (sInt(build_size_total) > IntType(1))) || (ObjType(obj_block_render_model, singlemodel)->random_offset_xy > 0 && (sInt(build_size_xy) > IntType(1))))
				{
					if (ObjType(obj_block_render_model, singlemodel)->random_offset > 0)
					{
						random_set_seed((IntType)(sInt(build_pos_x) * sInt(build_size_y) * sInt(build_size_z) + sInt(build_pos_y) * sInt(build_size_z) + sInt(build_pos_z)));
						sInt(block_pos_z) += irandom_range(-IntType(3), IntType(0));
					}
					else
						random_set_seed(sInt(build_pos_x) + sInt(build_size_x) * sInt(build_pos_y));
					
					sInt(block_pos_x) += irandom_range(-IntType(4), IntType(4));
					sInt(block_pos_y) += irandom_range(-IntType(4), IntType(4));
				}
			}
			sVar(block_vertex_emissive) = null_;
			sInt(block_vertex_wave) = idInt(sInt(block_current), wind_axis);
			if (idVar(sInt(block_current), wind_zmin) != null_)
				sInt(block_vertex_wave_zmin) = sInt(block_pos_z) + idVar(sInt(block_current), wind_zmin);
			sVar(block_vertex_subsurface) = idVar(sInt(block_current), subsurface);
			if (is_array(model))
			{
				for (IntType i = IntType(0); i < array_length(VarType::CreateRef(model)); i++)
					block_render_model_generate(Scope<obj_builder_thread>(self), global::block_rendermodels.Value(model.Value(i)));
			}
			else
				if (model > IntType(0))
					block_render_model_generate(Scope<obj_builder_thread>(self), global::block_rendermodels.Value(model));
			
		}
		
		sInt(block_vertex_wave) = e_vertex_wave_NONE;
		sInt(block_vertex_wave_zmin) = null_;
		sInt(block_vertex_wave_zmax) = null_;
		sVar(block_vertex_emissive) = IntType(0);
		sVar(block_vertex_subsurface) = IntType(0);
		if (builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y), sInt(build_pos_z)))
		{
			sInt(block_pos_x) = sInt(build_pos_x) * block_size_;
			sInt(block_pos_y) = sInt(build_pos_y) * block_size_;
			sInt(block_pos_z) = sInt(build_pos_z) * block_size_;
			sInt(block_current) = DsMap(ObjType(obj_minecraft_assets, global::mc_assets)->block_name_map).Value(/*"water"*/ STR(823));
			block_generate_liquid(self, true);
			sInt(block_vertex_wave) = e_vertex_wave_NONE;
			sInt(block_vertex_wave_zmin) = null_;
			sInt(block_vertex_wave_zmax) = null_;
			sVar(block_vertex_emissive) = IntType(0);
			sVar(block_vertex_subsurface) = IntType(0);
		}
		return 0.0;
	}
	
	BoolType builder_read_schematic(Scope<obj_builder> self, VarType map)
	{
		if (!ds_map_valid(map))
		{
			log({ /*"Schematic error"*/ STR(993), /*"Not a schematic file"*/ STR(994) });
			return false;
		}
		self->builder_scenery_legacy = is_undefined(DsMap(map).Value(/*"Palette"*/ STR(995)));
		self->build_size_x = DsMap(map).Value(/*"Width"*/ STR(996));
		self->build_size_y = DsMap(map).Value(/*"Length"*/ STR(997));
		self->build_size_z = DsMap(map).Value(/*"Height"*/ STR(998));
		log({ /*"Size"*/ STR(55), string(self->build_size_x) + /*" x "*/ STR(999) + string(self->build_size_y) + /*" x "*/ STR(999) + string(self->build_size_z) });
		if (is_undefined(self->build_size_x) || is_undefined(self->build_size_y) || is_undefined(self->build_size_z))
		{
			log({ /*"Schematic error"*/ STR(993), /*"Size not fully defined"*/ STR(1000) });
			return false;
		}
		if (self->build_size_x <= IntType(0) || self->build_size_y <= IntType(0) || self->build_size_z <= IntType(0))
		{
			log({ /*"Schematic error"*/ STR(993), /*"Size cannot be 0"*/ STR(1001) });
			return false;
		}
		if (!self->builder_scenery_legacy)
		{
			VarType version = DsMap(map).Value(/*"Version"*/ STR(1002));
			if (is_undefined(version))
			{
				log({ /*"Schematic error"*/ STR(993), /*"Version not available"*/ STR(1003) });
				return false;
			}
			log({ /*"Version"*/ STR(1002), DsMap(map).Value(/*"Version"*/ STR(1002)) });
			if (version > IntType(1))
			{
				log({ /*"Schematic error"*/ STR(993), /*"Unsupported format, version too high"*/ STR(1004) });
				return false;
			}
			VarType palettemap = DsMap(map).Value(/*"Palette"*/ STR(995));
			if (!ds_map_valid(palettemap))
			{
				log({ /*"Schematic error"*/ STR(993), /*"Palette not found"*/ STR(1005) });
				return false;
			}
			for (IntType i = IntType(0); i < ds_map_size((IntType)(palettemap)); i++)
			{
				self->sch_palette_blocks[i] = null_;
				self->sch_palette_stateids[i] = null_;
				self->sch_palette_waterlogged[i] = false;
			}
			VarType key = ds_map_find_first((IntType)(palettemap));
			while (!is_undefined(key))
			{
				if (!string_contains(key, /*"_NBT_"*/ STR(1006)))
				{
					VarType index;
					IntType bracketindex;
					index = DsMap(palettemap).Value(key);
					bracketindex = string_pos(/*"["*/ STR(1007), key);
					if (bracketindex > IntType(0))
					{
						StringType mcid = string_copy(key, IntType(1), (IntType)(bracketindex - IntType(1)));
						StringType varstr = string_copy(key, bracketindex + IntType(1), (IntType)(string_length(key) - IntType(1) - bracketindex));
						VarType block = DsMap(ObjType(obj_minecraft_assets, global::mc_assets)->block_id_map).Value(mcid);
						if (!is_undefined(block))
						{
							ArrType vars = ArrType();
							if (ObjType(obj_block, block)->id_state_vars_map != null_ && is_array(DsMap(ObjType(obj_block, block)->id_state_vars_map).Value(mcid)))
								state_vars_add(VarType::CreateRef(vars), DsMap(ObjType(obj_block, block)->id_state_vars_map).Value(mcid));
							state_vars_add(VarType::CreateRef(vars), string_get_state_vars(varstr));
							self->sch_palette_blocks[index] = block;
							self->sch_palette_stateids[index] = block_get_state_id(block, vars);
							if (state_vars_get_value(vars, /*"waterlogged"*/ STR(841)) != /*"false"*/ STR(784))
								if (ObjType(obj_block, block)->waterlogged > 0 || state_vars_get_value(vars, /*"waterlogged"*/ STR(841)) == /*"true"*/ STR(783))
									self->sch_palette_waterlogged[index] = true;
						}
					}
					else
						if (!is_undefined(DsMap(ObjType(obj_minecraft_assets, global::mc_assets)->block_id_map).Value(key)))
						{
							VarType block = DsMap(ObjType(obj_minecraft_assets, global::mc_assets)->block_id_map).Value(key);
							self->sch_palette_blocks[index] = block;
							if (ObjType(obj_block, block)->id_state_vars_map != null_ && is_array(DsMap(ObjType(obj_block, block)->id_state_vars_map).Value(key)))
								self->sch_palette_stateids[index] = block_get_state_id(block, DsMap(ObjType(obj_block, block)->id_state_vars_map).Value(key));
							else
								self->sch_palette_stateids[index] = IntType(0);
							
							self->sch_palette_waterlogged[index] = ObjType(obj_block, block)->waterlogged;
						}
					
				}
				key = ds_map_find_next((IntType)(palettemap), key);
			}
			
			self->sch_blockdata_array = DsMap(map).Value(/*"BlockData"*/ STR(1008));
			if (is_undefined(self->sch_blockdata_array))
			{
				log({ /*"Schematic error"*/ STR(993), /*"BlockData array not found"*/ STR(1009) });
				return false;
			}
			self->sch_blockdata_ints = (DsMap(map).Value(/*"BlockData_NBT_type"*/ STR(1010)) == e_nbt_TAG_INT_ARRAY);
			debug({ /*"blockdataints"*/ STR(1011), self->sch_blockdata_ints });
			VarType metadata = DsMap(map).Value(/*"Metadata"*/ STR(1012));
			if (ds_map_valid(metadata))
				self->file_map = DsMap(metadata).Value(/*"FromMap"*/ STR(1013));
		}
		else
		{
			self->sch_legacy_blocksarray = DsMap(map).Value(/*"Blocks"*/ STR(1014));
			if (is_undefined(self->sch_legacy_blocksarray))
			{
				log({ /*"Schematic error"*/ STR(993), /*"Blocks array not found"*/ STR(1015) });
				return false;
			}
			self->sch_legacy_dataarray = DsMap(map).Value(/*"Data"*/ STR(1016));
			if (is_undefined(self->sch_legacy_dataarray))
			{
				log({ /*"Schematic error"*/ STR(993), /*"Data array not found"*/ STR(1017) });
				return false;
			}
			self->file_map = DsMap(map).Value(/*"FromMap"*/ STR(1013));
		}
		
		if (is_undefined(self->file_map))
			self->file_map = /*""*/ STR(0);
		self->sch_tileentity_list = DsMap(map).Value(/*"TileEntities"*/ STR(1018));
		return true;
	}
	
	BoolType builder_read_schematic_nbt(ScopeAny self, VarType structuremap)
	{
		VarType structureversion, sizemap;
		sBool(scenery_structure) = true;
		structureversion = IntType(1);
		if (!is_undefined(DsMap(structuremap).Value(/*"DataVersion"*/ STR(1019))))
			structureversion = DsMap(structuremap).Value(/*"DataVersion"*/ STR(1019));
		if (structureversion < IntType(2000))
		{
			log({ /*"Structure error"*/ STR(1020), /*"Unsupported format, version too low"*/ STR(1021) });
			return false;
		}
		sizemap = DsMap(structuremap).Value(/*"size"*/ STR(1022));
		ObjType(obj_builder, global::mc_builder)->build_size_x = DsList(sizemap).Value(X_);
		ObjType(obj_builder, global::mc_builder)->build_size_y = DsList(sizemap).Value(Z_);
		ObjType(obj_builder, global::mc_builder)->build_size_z = DsList(sizemap).Value(Y_);
		log({ /*"Size"*/ STR(55), ArrType::From({ ObjType(obj_builder, global::mc_builder)->build_size_x, ObjType(obj_builder, global::mc_builder)->build_size_y, ObjType(obj_builder, global::mc_builder)->build_size_z }) });
		if (ObjType(obj_builder, global::mc_builder)->build_size_x <= IntType(0) || ObjType(obj_builder, global::mc_builder)->build_size_y <= IntType(0) || ObjType(obj_builder, global::mc_builder)->build_size_z <= IntType(0))
		{
			log({ /*"Structure error"*/ STR(1020), /*"Size cannot be 0"*/ STR(1001) });
			return false;
		}
		VarType paletteslist, palettelist;
		paletteslist = DsMap(structuremap).Value(/*"palettes"*/ STR(1023));
		if (ds_list_valid(paletteslist))
		{
			sInt(scenery_palette_size) = ds_list_size((IntType)(paletteslist));
			palettelist = DsList(paletteslist).Value(mod(sVar(scenery_palette), sInt(scenery_palette_size)));
		}
		else
		{
			palettelist = DsMap(structuremap).Value(/*"palette"*/ STR(1024));
			if (!ds_list_valid(palettelist))
			{
				log({ /*"Structure error"*/ STR(1020), /*"Palette not found"*/ STR(1005) });
				return false;
			}
		}
		
		ArrType paletteblocks, palettestateids, palettewaterlogged;
		for (IntType i = IntType(0); i < ds_list_size((IntType)(palettelist)); i++)
		{
			paletteblocks[i] = null_;
			palettestateids[i] = null_;
			palettewaterlogged[i] = false;
		}
		for (IntType i = IntType(0); i < ds_list_size((IntType)(palettelist)); i++)
		{
			VarType block, blockmap, mcid, propertiesmap, propertiesarr, key;
			blockmap = DsList(palettelist).Value(i);
			mcid = DsMap(blockmap).Value(/*"Name"*/ STR(1025));
			block = DsMap(ObjType(obj_minecraft_assets, global::mc_assets)->block_id_map).Value(mcid);
			propertiesarr = null_;
			if (!is_undefined(block))
			{
				ArrType vars = ArrType();
				if (ObjType(obj_block, block)->id_state_vars_map != null_ && is_array(DsMap(ObjType(obj_block, block)->id_state_vars_map).Value(mcid)))
					state_vars_add(VarType::CreateRef(vars), DsMap(ObjType(obj_block, block)->id_state_vars_map).Value(mcid));
				propertiesmap = DsMap(blockmap).Value(/*"Properties"*/ STR(989));
				if (!is_undefined(propertiesmap))
				{
					key = ds_map_find_first((IntType)(propertiesmap));
					IntType index = IntType(0);
					for (IntType j = IntType(0); j < ds_map_size((IntType)(propertiesmap)); j++)
					{
						if (!string_contains(key, /*"_NBT_"*/ STR(1006)))
						{
							propertiesarr[index * IntType(2)] = key;
							propertiesarr[index * IntType(2) + IntType(1)] = DsMap(propertiesmap).Value(key);
							index++;
						}
						key = ds_map_find_next((IntType)(propertiesmap), key);
					}
				}
				state_vars_add(VarType::CreateRef(vars), propertiesarr);
				paletteblocks[i] = block;
				palettestateids[i] = block_get_state_id(block, vars);
				if (state_vars_get_value(vars, /*"waterlogged"*/ STR(841)) != /*"false"*/ STR(784))
					if (ObjType(obj_block, block)->waterlogged > 0 || state_vars_get_value(vars, /*"waterlogged"*/ STR(841)) == /*"true"*/ STR(783))
						palettewaterlogged[i] = true;
			}
		}
		VarType blocklist = DsMap(structuremap).Value(/*"blocks"*/ STR(1026));
		if (!ds_list_valid(blocklist))
		{
			log({ /*"Structure error"*/ STR(1020), /*"Block list not found"*/ STR(1027) });
			return false;
		}
		withOne (obj_builder, global::mc_builder, self->id)
		{
			debug_timer_start();
			builder_start(self);
			for (IntType i = IntType(0); i < ds_list_size((IntType)(blocklist)); i++)
			{
				VarType blockmap, pos, state, block, stateid, entity, blocknbt;
				RealType index;
				IntType waterlogged;
				blockmap = DsList(blocklist).Value(i);
				pos = DsMap(blockmap).Value(/*"pos"*/ STR(1028));
				state = DsMap(blockmap).Value(/*"state"*/ STR(1029));
				index = DsList(pos).Value(Y_) * DsList(sizemap).Value(X_) * DsList(sizemap).Value(Z_) + DsList(pos).Value(Z_) * DsList(sizemap).Value(X_) + DsList(pos).Value(X_);
				block = paletteblocks.Value(state);
				stateid = palettestateids.Value(state);
				waterlogged = palettewaterlogged.Value(state);
				entity = null_;
				random_set_seed((IntType)(index));
				if (idVar(self.otherId, scenery_integrity_invert) > 0)
				{
					if (random(1.0) < idVar(self.otherId, scenery_integrity))
						continue;
				}
				else
				{
					if (random(1.0) > idVar(self.otherId, scenery_integrity))
						continue;
				}
				
				blocknbt = DsMap(blockmap).Value(/*"nbt"*/ STR(1030));
				if (!is_undefined(blocknbt))
				{
					VarType finalstate, script;
					finalstate = DsMap(blocknbt).Value(/*"final_state"*/ STR(1031));
					if (!is_undefined(finalstate))
					{
						block = DsMap(ObjType(obj_minecraft_assets, global::mc_assets)->block_id_map).Value(finalstate);
						if (is_undefined(block))
							continue;
						ArrType vars = ArrType();
						if (ObjType(obj_block, block)->id_state_vars_map != null_ && is_array(DsMap(ObjType(obj_block, block)->id_state_vars_map).Value(finalstate)))
							state_vars_add(VarType::CreateRef(vars), DsMap(ObjType(obj_block, block)->id_state_vars_map).Value(finalstate));
						stateid = block_get_state_id(block, vars);
					}
					else
						entity = DsMap(blocknbt).Value(/*"id"*/ STR(82));
					
				}
				if (block != null_)
				{
					buffer_poke(self->block_obj, (IntType)(index * IntType(2)), buffer_u16, ObjType(obj_block, block)->block_id);
					buffer_poke(self->block_state_id, (IntType)(index * IntType(2)), buffer_u16, (IntType)(stateid));
					buffer_poke(self->block_waterlogged, (IntType)(index), buffer_u8, waterlogged);
				}
				if (entity != null_)
				{
					self->script = asset_get_index(/*"block_tile_entity_"*/ STR(1032) + string_replace(string_lower(entity), /*"minecraft:"*/ STR(844), /*""*/ STR(0)));
					if (self->script > -IntType(1))
					{
						self->build_pos_x = DsList(pos).Value(X_);
						self->build_pos_y = DsList(pos).Value(Z_);
						self->build_pos_z = DsList(pos).Value(Y_);
						self->build_pos = self->build_pos_z * self->build_size_xy + self->build_pos_y * self->build_size_x + self->build_pos_x;
						self->block_current = builder_get_block(ScopeAny(self), self->build_pos_x, self->build_pos_y, self->build_pos_z);
						self->block_state_id_current = builder_get_state_id(ScopeAny(self), self->build_pos_x, self->build_pos_y, self->build_pos_z);
						script_execute(ScopeAny(self), { self->script, blocknbt });
					}
				}
			}
		}
		
		debug_timer_stop(/*"res_load_scenery, Parse blocks"*/ STR(1033));
		return true;
	}
	
	void builder_read_schematic_tile_entities(Scope<obj_builder> self)
	{
		if (ds_list_valid(self->sch_tileentity_list))
		{
			builder_spawn_threads(self, IntType(1));
			withOne (obj_builder_thread, DsList(self->thread_list).Value(IntType(0)), self->id)
			{
				debug_timer_start();
				for (IntType i = IntType(0); i < ds_list_size((IntType)(ObjType(obj_builder, self.otherId)->sch_tileentity_list)); i++)
				{
					VarType entity, eid, ex, ey, ez;
					entity = DsList(ObjType(obj_builder, self.otherId)->sch_tileentity_list).Value(i);
					if (!self->builder_scenery_legacy)
					{
						eid = DsMap(entity).Value(/*"Id"*/ STR(988));
						VarType poslist = DsMap(entity).Value(/*"Pos"*/ STR(1035));
						buffer_seek(global::buffer_current, buffer_seek_start, (IntType)(poslist));
						ex = buffer_read_int_be();
						ez = buffer_read_int_be();
						ey = buffer_read_int_be();
					}
					else
					{
						eid = DsMap(entity).Value(/*"id"*/ STR(82));
						ex = DsMap(entity).Value(/*"x"*/ STR(856));
						ey = DsMap(entity).Value(/*"z"*/ STR(857));
						ez = DsMap(entity).Value(/*"y"*/ STR(839));
					}
					
					if (is_string(eid))
					{
						VarType script = asset_get_index(/*"block_tile_entity_"*/ STR(1032) + string_replace(string_lower(eid), /*"minecraft:"*/ STR(844), /*""*/ STR(0)));
						if (script > -IntType(1))
						{
							self->build_pos_x = ex;
							self->build_pos_y = ey;
							self->build_pos_z = ez;
							self->build_pos = self->build_pos_z * self->build_size_xy + self->build_pos_y * self->build_size_x + self->build_pos_x;
							self->block_current = builder_get_block(ScopeAny(self), self->build_pos_x, self->build_pos_y, self->build_pos_z);
							self->block_state_id_current = builder_get_state_id(ScopeAny(self), self->build_pos_x, self->build_pos_y, self->build_pos_z);
							script_execute(ScopeAny(self), { script, entity });
						}
					}
				}
				debug_timer_stop(/*"Parse Tile Entities"*/ STR(1036));
			}
			
			builder_combine_threads(self);
		}
	}
	
	VarType builder_set_model(ScopeAny self, BoolType ongeneration)
	{
		sInt(block_current) = builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y), sInt(build_pos_z));
		if (sInt(block_current) == null_)
			return IntType(0);
		sReal(block_state_id_current) = builder_get_state_id(self, sInt(build_pos_x), sInt(build_pos_y), sInt(build_pos_z));
		VarType model, ret;
		model = null_;
		ret = IntType(0);
		if (idInt(sInt(block_current), set_script) > -IntType(1))
		{
			if (!(idVar(sInt(block_current), require_models) > 0) || ongeneration)
			{
				sBool(build_edge_xp) = (sInt(build_pos_x) == sInt(build_size_x) - IntType(1));
				sBool(build_edge_xn) = (sInt(build_pos_x) == IntType(0));
				sBool(build_edge_yp) = (sInt(build_pos_y) == sInt(build_size_y) - IntType(1));
				sBool(build_edge_yn) = (sInt(build_pos_y) == IntType(0));
				sBool(build_edge_zp) = (sInt(build_pos_z) == sInt(build_size_z) - IntType(1));
				sBool(build_edge_zn) = (sInt(build_pos_z) == IntType(0));
				ret = script_execute(self, { idInt(sInt(block_current), set_script) });
				if (ret != IntType(0))
					model = ret;
			}
			else
				ret = null_;
			
		}
		BoolType tlvalid = (ObjType(obj_builder, global::mc_builder)->block_tl_add == null_ || ObjType(obj_builder, global::mc_builder)->block_tl_add > 0) && idVar(sInt(block_current), timeline) > 0 && sInt(block_tl_map) != null_ && ret != null_;
		if (tlvalid && !(idVar(sInt(block_current), model_double) > 0))
			DsMap(sInt(block_tl_map))[sInt(build_pos)] = ArrType::From({ sInt(block_current), sReal(block_state_id_current) });
		else
		{
			if (tlvalid && idVar(sInt(block_current), model_double) > 0)
				DsMap(sInt(block_tl_map))[sInt(build_pos)] = ArrType::From({ sInt(block_current), sReal(block_state_id_current) });
			if (ret == IntType(0) && idVar(sInt(block_current), state_id_model_obj) != null_)
			{
				VarType modelobj = idVar(sInt(block_current), state_id_model_obj).Value(sReal(block_state_id_current));
				if (modelobj != null_ && !is_undefined(modelobj))
				{
					VarType brightness, offset, offsetxy;
					brightness = idVar(sInt(block_current), state_id_emissive).Value(sReal(block_state_id_current));
					offset = idVar(sInt(block_current), state_id_random_offset).Value(sReal(block_state_id_current));
					offsetxy = idVar(sInt(block_current), state_id_random_offset_xy).Value(sReal(block_state_id_current));
					if (is_array(modelobj))
					{
						model = ArrType();
						for (IntType i = IntType(0); i < array_length(VarType::CreateRef(modelobj)); i++)
							array_add(VarType::CreateRef(model), block_get_render_model(modelobj.Value(i), brightness, offset, offsetxy));
					}
					else
						model = block_get_render_model(modelobj, brightness, offset, offsetxy);
					
				}
			}
			if (is_array(model))
				DsMap(sInt(block_render_model_multipart_map))[sInt(build_pos)] = model;
			else
				if (model != null_)
					builder_set_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y), sInt(build_pos_z), model);
			
		}
		
		return model;
	}
	
	void builder_spawn_threads(Scope<obj_builder> self, IntType number)
	{
		for (IntType t = IntType(0); t < number; t++)
		{
			IntType thread = (new obj_builder_thread)->id;
			ObjType(obj_builder_thread, thread)->threadid = t;
			ObjType(obj_builder_thread, thread)->block_obj = self->block_obj;
			ObjType(obj_builder_thread, thread)->block_state_id = self->block_state_id;
			ObjType(obj_builder_thread, thread)->block_waterlogged = self->block_waterlogged;
			ObjType(obj_builder_thread, thread)->build_size_x = self->build_size_x;
			ObjType(obj_builder_thread, thread)->build_size_y = self->build_size_y;
			ObjType(obj_builder_thread, thread)->build_size_z = self->build_size_z;
			ObjType(obj_builder_thread, thread)->build_size_xy = self->build_size_xy;
			ObjType(obj_builder_thread, thread)->build_size_total = self->build_size_total;
			ObjType(obj_builder_thread, thread)->build_size_sqrt = self->build_size_sqrt;
			ObjType(obj_builder_thread, thread)->block_render_model = self->block_render_model;
			ObjType(obj_builder_thread, thread)->block_render_model_multipart_map = ds_int_map_create();
			ObjType(obj_builder_thread, thread)->block_multithreaded_skip = false;
			ObjType(obj_builder_thread, thread)->builder_scenery = self->builder_scenery;
			ObjType(obj_builder_thread, thread)->builder_scenery_legacy = self->builder_scenery_legacy;
			if (self->block_tl_list != null_)
				ObjType(obj_builder_thread, thread)->block_tl_map = ds_int_map_create();
			ds_list_add({ self->thread_list, thread });
		}
		if (number > IntType(1))
			thread_task_begin();
	}
	
	void builder_start(Scope<obj_builder> self)
	{
		self->build_pos = IntType(0);
		self->build_size_xy = self->build_size_x * self->build_size_y;
		self->build_size_total = self->build_size_xy * self->build_size_z;
		self->build_edges = !(global::_app->setting_scenery_remove_edges > 0 && (self->build_size_x > IntType(300) && self->build_size_y > IntType(300)) && self->build_single_block == null_);
		self->block_tl_add = false;
		self->block_multithreaded_skip = false;
		ds_map_clear(self->block_text_front_map);
		ds_map_clear(self->block_text_front_color_map);
		ds_map_clear(self->block_text_front_glow_color_map);
		ds_map_clear(self->block_text_front_glowing_map);
		ds_map_clear(self->block_text_back_map);
		ds_map_clear(self->block_text_back_color_map);
		ds_map_clear(self->block_text_back_glowing_map);
		ds_map_clear(self->block_banner_color_map);
		ds_map_clear(self->block_banner_patterns_map);
		ds_map_clear(self->block_banner_pattern_colors_map);
		ds_map_clear(self->block_skull_map);
		ds_map_clear(self->block_skull_res_map);
		ds_map_clear(self->block_skull_texture_map);
		ds_map_clear(self->block_decorated_pot_sherds_map);
		builder_create_buffers(self);
	}
	
	void builder_thread_event_create(Scope<obj_builder_thread> self)
	{
		self->threadid = IntType(0);
		self->build_size_x = IntType(0);
		self->build_size_y = IntType(0);
		self->build_size_z = IntType(0);
		self->build_size_total = IntType(0);
		self->build_size_sqrt = IntType(0);
		self->build_pos = IntType(0);
		self->build_pos_x = IntType(0);
		self->build_pos_y = IntType(0);
		self->build_pos_z = IntType(0);
		self->build_edge_xp = false;
		self->build_edge_xn = false;
		self->build_edge_yp = false;
		self->build_edge_yn = false;
		self->build_edge_zp = false;
		self->build_edge_zn = false;
		self->builder_scenery = false;
		self->builder_scenery_legacy = false;
		self->block_pos_x = IntType(0);
		self->block_pos_y = IntType(0);
		self->block_pos_z = IntType(0);
		self->block_color = null_;
		self->block_face_min_depth_xp = null_;
		self->block_face_min_depth_xn = null_;
		self->block_face_min_depth_yp = null_;
		self->block_face_min_depth_yn = null_;
		self->block_face_min_depth_zp = null_;
		self->block_face_min_depth_zn = null_;
		self->block_obj = null_;
		self->block_waterlogged = null_;
		self->block_current = IntType(0);
		self->block_state_id = null_;
		self->block_state_id_current = IntType(0);
		self->block_render_model = null_;
		self->block_render_model_multipart_map = null_;
		self->block_tl_map = null_;
		self->block_vbuffer_current = null_;
		self->block_vertex_wave = e_vertex_wave_NONE;
		self->block_vertex_wave_zmin = null_;
		self->block_vertex_wave_zmax = null_;
		self->block_vertex_emissive = IntType(0);
		self->block_vertex_subsurface = IntType(0);
		self->block_vertex_rgb = c_white;
		self->block_vertex_alpha = IntType(1);
	}
	
	void camera_control_move(ScopeAny self, VarType cam, IntType lockx, IntType locky)
	{
		RealType mx, my;
		mx = -((display_mouse_get_x() - lockx) / 8.0) * sReal(setting_look_sensitivity);
		my = -((display_mouse_get_y() - locky) / 8.0) * sReal(setting_look_sensitivity);
		display_mouse_set(lockx, locky);
		if (!(cam > 0))
		{
			RealType move, spd, spdm, xd, yd, zd;
			sVar(cam_work_angle_look_xy) += mx;
			sVar(cam_work_angle_look_z) += my;
			sVar(cam_work_angle_look_z) = clamp(sVar(cam_work_angle_look_z), -89.9, 89.9);
			if (!(sInt(cam_work_focus_tl) > 0) && (mx != IntType(0) || my != IntType(0)))
			{
				camera_work_set_focus();
				camera_work_set_angle();
			}
			move = IntType(4) * sReal(setting_move_speed) * global::delta;
			spd = (ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_FORWARD))->active - ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_BACK))->active) * move;
			spdm = IntType(1);
			if (ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_FAST))->active > 0)
				spdm = sReal(setting_fast_modifier);
			if (ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_SLOW))->active > 0)
				spdm = sReal(setting_slow_modifier);
			xd = IntType(0);
			yd = IntType(0);
			if (ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_RIGHT))->active > 0)
			{
				xd += -sin(degtorad(sVar(cam_work_angle_look_xy))) * move;
				yd += -cos(degtorad(sVar(cam_work_angle_look_xy))) * move;
			}
			if (ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_LEFT))->active > 0)
			{
				xd += sin(degtorad(sVar(cam_work_angle_look_xy))) * move;
				yd += cos(degtorad(sVar(cam_work_angle_look_xy))) * move;
			}
			xd += -lengthdir_x(spd, sVar(cam_work_angle_look_xy));
			yd += -lengthdir_y(spd, sVar(cam_work_angle_look_xy));
			zd = (ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_ASCEND))->active - ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_DESCEND))->active) * move;
			zd += (dsin(sVar(cam_work_angle_look_z))) * (ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_FORWARD))->active - ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_BACK))->active) * move;
			sVec(cam_work_from).Real(X_) += xd * spdm;
			sVec(cam_work_from).Real(Y_) += yd * spdm;
			sVec(cam_work_from).Real(Z_) += zd * spdm;
			if (!(sInt(cam_work_focus_tl) > 0))
			{
				sVar(cam_work_focus)[X_] += xd * spdm;
				sVar(cam_work_focus)[Y_] += yd * spdm;
				sVar(cam_work_focus)[Z_] += zd * spdm;
			}
			if (ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_RESET))->pressed)
				camera_work_reset(self);
			if (xd != IntType(0) || yd != IntType(0) || zd != IntType(0) || mx != IntType(0) || my != IntType(0))
				camera_work_set_angle();
		}
		else
		{
			RealType move, roll, spd, spdm, xd, yd, zd;
			move = IntType(4) * sReal(setting_move_speed) * global::delta;
			spd = (ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_FORWARD))->active - ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_BACK))->active) * move;
			spdm = IntType(1);
			if (ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_FAST))->active > 0)
				spdm = sReal(setting_fast_modifier);
			if (ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_SLOW))->active > 0)
				spdm = sReal(setting_slow_modifier);
			xd = IntType(0);
			yd = IntType(0);
			if (ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_RIGHT))->active > 0)
			{
				xd += -sin(degtorad(idVar(cam, value).Value(e_value_ROT_Z) + 90.0)) * move;
				yd += -cos(degtorad(idVar(cam, value).Value(e_value_ROT_Z) + 90.0)) * move;
			}
			if (ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_LEFT))->active > 0)
			{
				xd += sin(degtorad(idVar(cam, value).Value(e_value_ROT_Z) + 90.0)) * move;
				yd += cos(degtorad(idVar(cam, value).Value(e_value_ROT_Z) + 90.0)) * move;
			}
			xd += -lengthdir_x(spd, idVar(cam, value).Value(e_value_ROT_Z) + 90.0);
			yd += -lengthdir_y(spd, idVar(cam, value).Value(e_value_ROT_Z) + 90.0);
			zd = (ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_ASCEND))->active - ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_DESCEND))->active) * move;
			zd += (-dsin(idVar(cam, value).Value(e_value_ROT_X))) * (ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_FORWARD))->active - ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_BACK))->active) * move;
			roll = (ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_ROLL_FORWARD))->active - ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_ROLL_BACK))->active) * IntType(4) * spdm * global::delta;
			tl_value_set_start(self, ID_camera_control_move, true);
			tl_value_set(self, { e_value_POS_X, xd * spdm, true });
			tl_value_set(self, { e_value_POS_Y, yd * spdm, true });
			tl_value_set(self, { e_value_POS_Z, zd * spdm, true });
			tl_value_set(self, { e_value_ROT_X, -my, true });
			tl_value_set(self, { e_value_ROT_Y, roll, true });
			tl_value_set(self, { e_value_ROT_Z, mx, true });
			if (ObjType(obj_keybind, global::keybinds.Value(e_keybind_CAM_ROLL_RESET))->active > 0)
				tl_value_set(self, { e_value_ROT_Y, IntType(0), false });
			tl_value_set_done();
		}
		
	}
	
}
